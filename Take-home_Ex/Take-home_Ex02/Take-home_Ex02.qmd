---
title: "Take Home Exercise 02"
author: "Pan Mingwei"
date: "September 24, 2024"
date-modified: "last-modified"
execute: 
  eval: true
  echo: true
  warning: false
  cache: true
  freeze: true
format: 
  html: 
    code-fold: false
    code-summary: "Click to expand/collapse code"
---

# 1. Overview

Drug abuse is associated with significant negative health, financial and social consequences. Yet, illicit drug consumption remains highly prevalent and continues to be a growing problem worldwide. In 2021, 1 in 17 people aged 15–64 in the world had used a drug in the past 12 months. Notwithstanding population growth, the estimated number of drug users grew from 240 million in 2011 to 296 million in 2021.

The geopolitics of Thailand which is near the [Golden Triangle](https://en.wikipedia.org/wiki/Golden_Triangle_(Southeast_Asia)) of Indochina, the largest drug production site in Asia, and the constant transportation infrastructure development made Thailand became market and transit routes for drug trafficking to the third countries.

In Thailand, drug abuse is one of the major social issue. There are about 2.7 million youths using drugs in Thailand. Among youths aged between 15 and 19 years, there are about 300,000 who have needs for drug treatment. Most of Thai youths involved with drugs are vocational-school students, which nearly doubles in number compared to secondary-school students.

## 1.1 The Objective

This take-home exercise will focus on determining:

-   if the key indicators of drug abuse of Thailand are independent from space.

-   If the indicators of drug abuse is indeed spatial dependent, then, identify where are the clusters and outliers, and the hotspots.

-   Last, investigate how the observation above evolve over time.

## 1.2 The Task

-   Use **sf** and **tidyverse** to prepare the geospatial data layer:

    -   a study area layer of province level(including Bangkok).

    -   a drug abuse indicators layer within the study area.

-   Perform Global Spatial Autocorrelation Analysis using **sfdep**.

-   Perform Local Spatial Autocorrelation Analysis using **sfdep**.

-   Analysis the spatial patterns.

## 1.3 The Data

-   [Thailand Drug Offenses \[2017-2022\]](https://www.kaggle.com/datasets/thaweewatboy/thailand-drug-offenses-2017-2022) at Kaggle.

-   [Thailand - Subnational Administrative Boundaries](https://data.humdata.org/dataset/cod-ab-tha?) at HDX. You are required to use the province boundary data set.

# 2. Getting Started

## 2.1 Load R Packages

-   **sf** is use for importing and handling geospatial data in R,

-   **tidyverse** is mainly use for wrangling attribute data in R,

-   **sfped,** builds on the great shoulders of spdep package for spatial dependence. sfdep creates an sf and tidyverse friendly interface

-   **tmap** will be used to prepare cartographic quality choropleth map.

-   **gridExtra**, will be used to arrange grid-based plot, such as ggplot.

-   **plotly**, will be used to plot interactive graphs.

-   **Kendall**, computes the Kendall rank correlation and Mann-Kendall trend test.

```{r}
pacman::p_load(sf, sfdep, tmap, tidyverse, gridExtra, plotly,Kendall)
```

## 2.2 Load the Data

### 2.2.1 Geospatial Data

Loading the Thailand_Subnational_Administrative1_Boundaries dataset, which contain the province boundary including Bandkok of Thailand. Using `st_read()` of **sf** package.

```{r}
thailand_sf <- st_read(dsn = "data/geospatial", 
                 layer = "Thailand_Subnational_Administrative1_Boundaries")
```

There are 77 geographic features, which aligns with expectations. This includes 76 provinces at the first-order administrative level and the capital city, Bangkok.

Next, lets visualise **thailand_sf** using **tmap** package.

```{r,fig.width=12,fig.height=10}
tmap_mode("plot")
tm_shape(thailand_sf)+
  tm_fill(col="white")+
  tm_borders(col = "black", lwd=0.5, alpha=0.5)+
  tm_layout(
    main.title = "Thailand Provinces (including Bandkok)",
    main.title.size = 1.5,
    main.title.position = "center",
    legend.show = FALSE,
     frame = FALSE)
```

### 2.2.2 Aspatial Data

Load Thailand drug offenses\[2017 - 2022\] dataset, using **`read_csv()`** from **readr** package.

```{r}
drug <- read_csv("data/aspatial/thai_drug_offenses_2017_2022.csv")
```

# 3. Data Wrangling

## 3.1 Remove Columns

As there some columns that would not be useful in our analysis. Therefore, it is good practice by removing those column.

Before we removing the column. Lets list down the column for the two data set.

```{r}
colnames(thailand_sf)
```

```{r}
colnames(drug)
```

Based on the columns list on the two dataset and after browsing the data, the following fields I will keep:

-   thailand_sf

    -   ADM1_EN (common field with the drug dataset) =\> column 3

    -   geometry =\> column 17

-   drug

    -   fiscal_year =\> column 1

    -   types_of_drug_offenses =\> column 2

    -   no_cases =\> column 3

    -   province_en =\> column 5

```{r}
thailand_sf <- thailand_sf %>%
  select("province_en" = 3,17) # change the ADM1_EN to province_en
```

```{r}
drug <- drug %>%
  select(1:3,5)
```

```{r}
sum(apply(drug, 1, function(x) any(is.na(x))))
```

## 3.2 Checking the common field

Since we need to join the two datasets, it’s important to ensure that all the values in the common column match correctly.

```{r}
check_match <- setdiff(thailand_sf$province_en, drug$province_en)
check_match # print the mismatch field in thailand_sf
check_match <- setdiff(drug$province_en, thailand_sf$province_en)
check_match # print the mismatch field in drug
```

I observe that two provinces have names in different formats ("Lop Buri" and "Bueng Kan"). Let's modify the values in the `drug` dataset to match the naming convention used in the `thailand_sf` dataset.

```{r}
drug <- drug %>%
  mutate(province_en = case_when(
    province_en == "Loburi" ~ "Lop Buri",
    province_en == "buogkan" ~ "Bueng Kan",
    TRUE ~ province_en
  ))
```

Lets check, if there still have any mismatch.

```{r}
check_match <- setdiff(thailand_sf$province_en, drug$province_en)
check_match

```

## 3.3 Checking Types of Drug Offenses

As in the dataset, there are many different types of drug offenses. In order to get better insight. I decide to further check in the column and see which are the type I should consider.

```{r}
unique_types <- unique(drug$types_of_drug_offenses)
print(unique_types)
```

To get a better sense of the field, and decide which type I should focus on. I will group the type using the code chunk.

```{r}
drug_counts <- drug %>%
  group_by(types_of_drug_offenses) %>%
  summarise(total_cases = sum(no_cases, na.rm = TRUE),, .groups = 'drop')
```

To visualise the data.

```{r,fig.width=12,fig.height=10}
ggplot(drug_counts, aes(x = types_of_drug_offenses, y = total_cases, fill = types_of_drug_offenses)) +
  geom_bar(stat = "identity") +  # Use stat = "identity" for summarized data
  labs(title = "Total Cases of Drug Offenses by Type",
       x = "Types of Drug Offenses",
       y = "Total Cases") +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))  # Rotate x-axis labels for better visibility
```

Based on the plot, we can observe that **drug use cases** and **suspects in possession cases** have been the most common offenses over the years. However, since possession cases may not accurately reflect the severity of drug abuse in Thailand, my analysis will focus on drug use cases. This approach provides more reliable data on the prevalence and severity of drug abuse in each province, as actual drug use offers clearer indicators of abuse trends. By narrowing the scope to drug use cases, I aim to draw more precise conclusions about the drug abuse situation in Thailand from 2017 to 2022.

The following code chunk filters the dataset to retain only the `drug_use_cases`, ensuring that the analysis focuses solely on actual drug use incidents.

```{r}
drug_use_cases <- drug %>%
  filter(types_of_drug_offenses == "drug_use_cases")
```

Since, there is no mismatch in the province_en column, we can combine both data frame using **`left_join()`** of **dplyr** package.

```{r}
drug_use_cases <- left_join(thailand_sf, drug_use_cases)
```

```{r}
#| eval: false
write_rds(drug_use_cases,"data/rds/drug_use_cases.rds")
```

Lets visualising the drug use case over the years.

```{r,fig.width=12,fig.height=10}
tmap_mode("plot")
tm_shape(drug_use_cases) +
  tm_fill("no_cases", 
          style = "quantile", 
          palette = "Blues",
          title = "total_cases") +
  tm_layout(main.title = "Distribution of drug use cases",
            main.title.position = "center",
            main.title.size = 1.2,
            legend.height = 0.45, 
            legend.width = 0.35,
            frame = TRUE) +
  tm_facets(by = "fiscal_year", free.coords = FALSE) +
  tm_borders(alpha = 0.5) +
  tm_compass(type="8star", size = 2) +
  tm_scale_bar() +
  tm_grid(alpha =0.2)
```

# 4. Global Measures of Spatial Autocorrelation

To evaluate the overall degree of spatial dependence (autocorrelation) across the entire study area for each year.

## 4.1 Global Moran's I Test

I decided to use Queen contiguity for the neighbors, as it shares both edges and corners, providing a more comprehensive result in helping me determine whether the drug use cases are independent of their locations.

I've observed that Phuket(67) is an island, which means that `st_contiguity` cannot identify any polygon neighbors for it. Therefore, I will set allow_zero to be TRUE.

![](website_img/Phuket_location.jpg){fig-align="center"}

::: panel-tabset
## 2017

```{r}
#| code-fold: true
# Deriving Queen’s contiguity weights
wm_q_2017 <- drug_use_cases %>%
  filter(fiscal_year == 2017) %>%
  mutate(nb = st_contiguity(geometry),
         wt = st_weights(nb,
                         style = "W", allow_zero = TRUE),
         .before = 1)
```

```{r}
#| code-fold: true
global_moran_test(wm_q_2017$no_cases,
                       wm_q_2017$nb,
                       wm_q_2017$wt,
                       zero.policy = TRUE,)
```

The results show an I value of 0.077, is close to zero, and a p-value of 0.06618, which exceeds the alpha level of 0.05. Therefore, we **do not have sufficient statistical evidence** to reject the null hypothesis, indicating that the spatial distribution of drug use cases in Thailand was random in 2017.

To strengthen the finding, we can run Monte carlo simulation to perform the statistical test.

```{r}
#| code-fold: true
set.seed(1234) # To ensure reproducible
moran_mc_2017_res = global_moran_perm(wm_q_2017$no_cases,
                       wm_q_2017$nb,
                       wm_q_2017$wt,
                        nsim=999,
                       zero.policy = TRUE,)
moran_mc_2017_res
```

From the simulation results, we can observed that the p-value have increased, which further indicate that we **cannot reject** the null hypothesis.

Lets check the summary statistics using **summary()** function.

```{r}
#| code-fold: true
summary(moran_mc_2017_res$res)
```

To visualise the monte-carlo simulation, we can plot a histogram. The statistic I value for 2017 was 0.07 which fall under the random section of the simulation result. As such, we **cannot reject** the null hypothesis.

```{r,fig.width=12,fig.height=10}
#| code-fold: true
ggplot() + 
  aes(moran_mc_2017_res$res[1:999]) + 
  geom_histogram(colour="black", fill="grey") +
  geom_vline(xintercept = 0, color = "red", linetype = "solid", size = 1) +
  labs(title = "Histogram of Simulated Moran's I For Thailand Drug Use Cases 2017",
       x = "Simulated Moran's I",
       y = "Frequency") +
  theme_minimal()
```

## 2018

```{r}
#| code-fold: true
# Deriving Queen’s contiguity weights
wm_q_2018 <- drug_use_cases %>%
  filter(fiscal_year == 2018) %>%
  mutate(nb = st_contiguity(geometry),
         wt = st_weights(nb,
                         style = "W", allow_zero = TRUE),
         .before = 1)
```

```{r}
#| code-fold: true
global_moran_test(wm_q_2018$no_cases,
                       wm_q_2018$nb,
                       wm_q_2018$wt,
                       zero.policy = TRUE,)
```

From the above result with I = 0.09 and the p-value = 0.4716 is smaller than alpha value of 0.05. Hence, we have statistical evidence to **reject** the null hypothesis and since the I value is positive but close to 0, so we can infer that the spatial distribution shows a **weak sign of clustering** in 2018.

```{r}
#| code-fold: true
set.seed(1234) # To ensure reproducible
moran_mc_2018_res = global_moran_perm(wm_q_2018$no_cases,
                       wm_q_2018$nb,
                       wm_q_2018$wt,
                        nsim=999,
                       zero.policy = TRUE,)
moran_mc_2018_res
```

However, based on the simulation, we can observed that the p-value has become larger than the alpha value of 0.05. Hence, based on the simulation result, we **do not have statistical evidence** to **reject** the null hypothesis that the spatial distribution of drug use case in Thailand are resemble random distribution for Year 2018.

To check the summary statistics.

```{r}
#| code-fold: true
summary(moran_mc_2018_res$res)
```

Based on the histogram, the result similar to Year 2017, the statistic I value still fall under the random section(0.09). As such, we **cannot reject** the null hypothesis.

```{r,fig.width=12,fig.height=10}
#| code-fold: true
ggplot() + 
  aes(moran_mc_2018_res$res[1:999]) + 
  geom_histogram(colour="black", fill="grey") +
  geom_vline(xintercept = 0, color = "red", linetype = "solid", size = 1) +
  labs(title = "Histogram of Simulated Moran's I For Thailand Drug Use Cases 2018",
       x = "Simulated Moran's I",
       y = "Frequency") +
  theme_minimal()
```

## 2019

```{r}
#| code-fold: true
# Deriving Queen’s contiguity weights
wm_q_2019 <- drug_use_cases %>%
  filter(fiscal_year == 2019) %>%
  mutate(nb = st_contiguity(geometry),
         wt = st_weights(nb,
                         style = "W", allow_zero = TRUE),
         .before = 1)
```

```{r}
#| code-fold: true
global_moran_test(wm_q_2019$no_cases,
                       wm_q_2019$nb,
                       wm_q_2019$wt,
                       zero.policy = TRUE,)
```

```{r}
#| code-fold: true
set.seed(1234) # To ensure reproducible
moran_mc_2019_res = global_moran_perm(wm_q_2019$no_cases,
                       wm_q_2019$nb,
                       wm_q_2019$wt,
                        nsim=999,
                       zero.policy = TRUE,)
moran_mc_2019_res
```

Based on the Moran I test and simulation result, we can observed that the p-value have become larger than 0.05 in the statistical test. Hence, we **do not have enough statistical evidence** to reject the null hypothesis that the spatial distribution of drug use case in Thailand are resemble random distribution for Year 2019. However, notice that the p-value is actually very close to the alpha value of 0.05, so based on this, we can infer that even we do not have enough statistical evidence to reject the null hypothesis, but it also give us insight that the drug use case in 2019, is probably higher than Year 2017 and 2018.

Check the summary statistics.

```{r}
#| code-fold: true
summary(moran_mc_2019_res$res)
```

Based on the histogram, we can observed that the statistic I value of 0.13 fall under the random section but very close to the alpha-value section.

```{r,fig.width=12,fig.height=10}
#| code-fold: true
ggplot() + 
  aes(moran_mc_2019_res$res[1:999]) + 
  geom_histogram(colour="black", fill="grey") +
  geom_vline(xintercept = 0, color = "red", linetype = "solid", size = 1) +
  labs(title = "Histogram of Simulated Moran's I For Thailand Drug Use Cases 2019",
       x = "Simulated Moran's I",
       y = "Frequency") +
  theme_minimal()
```

## 2020

```{r}
#| code-fold: true
# Deriving Queen’s contiguity weights
wm_q_2020 <- drug_use_cases %>%
  filter(fiscal_year == 2020) %>%
  mutate(nb = st_contiguity(geometry),
         wt = st_weights(nb,
                         style = "W", allow_zero = TRUE),
         .before = 1)
```

```{r}
#| code-fold: true
global_moran_test(wm_q_2020$no_cases,
                       wm_q_2020$nb,
                       wm_q_2020$wt,
                       zero.policy = TRUE,)
```

```{r}
#| code-fold: true
set.seed(1234) # To ensure reproducible
moran_mc_2020_res = global_moran_perm(wm_q_2020$no_cases,
                       wm_q_2020$nb,
                       wm_q_2020$wt,
                        nsim=999,
                       zero.policy = TRUE,)
moran_mc_2020_res
```

Based on the Moran I test and simulation result, we can observed that the p-value have become larger than 0.05 in the statistical test. Hence, we **do not have enough statistical evidence** to reject the null hypothesis that the spatial distribution of drug use case in Thailand are resemble random distribution for Year 2020.

The summary of the simulation statistics.

```{r}
#| code-fold: true
summary(moran_mc_2020_res$res)
```

Based on the histogram of the simulation, shows that the statistic I value of 0.08, fall in the random section.

```{r,fig.width=12,fig.height=10}
#| code-fold: true
ggplot() + 
  aes(moran_mc_2020_res$res[1:999]) + 
  geom_histogram(colour="black", fill="grey") +
  geom_vline(xintercept = 0, color = "red", linetype = "solid", size = 1) +
  labs(title = "Histogram of Simulated Moran's I For Thailand Drug Use Cases 2020",
       x = "Simulated Moran's I",
       y = "Frequency") +
  theme_minimal()
```

## 2021

```{r}
#| code-fold: true
# Deriving Queen’s contiguity weights
wm_q_2021 <- drug_use_cases %>%
  filter(fiscal_year == 2021) %>%
  mutate(nb = st_contiguity(geometry),
         wt = st_weights(nb,
                         style = "W", allow_zero = TRUE),
         .before = 1)
```

```{r}
#| code-fold: true
global_moran_test(wm_q_2021$no_cases,
                       wm_q_2021$nb,
                       wm_q_2021$wt,
                       zero.policy = TRUE,)
```

```{r}
#| code-fold: true
set.seed(1234) # To ensure reproducible
moran_mc_2021_res = global_moran_perm(wm_q_2021$no_cases,
                       wm_q_2021$nb,
                       wm_q_2021$wt,
                        nsim=999,
                       zero.policy = TRUE,)
moran_mc_2021_res
```

Based on the Moran I test and simulation result, we can observed that the p-value is still smaller than 0.05 in the statistical test. Hence, we **have enough statistical evidence** to reject the null hypothesis that the spatial distribution of drug use case in Thailand are not resemble random distribution for Year 2021. Since I is positive value of 0.2, hence we can infer that the spatial distribution of drag use in Thailand in 2021 shows sign of **weak clustering**.

To check the simulation statisitcs.

```{r}
#| code-fold: true
summary(moran_mc_2021_res$res)
```

Based on the histogram, our statistic I value of 0.20376 falls under the alpha-value range. Hence, we can reject the null hypothesis and can infer there is a weak sign of spatial autocorrelation in the drug use case across different locations.

```{r,fig.width=12,fig.height=10}
#| code-fold: true
ggplot() + 
  aes(moran_mc_2021_res$res[1:999]) + 
  geom_histogram(colour="black", fill="grey") +
  geom_vline(xintercept = 0, color = "red", linetype = "solid", size = 1) +
  labs(title = "Histogram of Simulated Moran's I For Thailand Drug Use Cases 2021",
       x = "Simulated Moran's I",
       y = "Frequency") +
  theme_minimal()
```

## 2022

```{r}
#| code-fold: true
# Deriving Queen’s contiguity weights
wm_q_2022 <- drug_use_cases %>%
  filter(fiscal_year == 2022) %>%
  mutate(nb = st_contiguity(geometry),
         wt = st_weights(nb,
                         style = "W", allow_zero = TRUE),
         .before = 1)
```

```{r}
#| code-fold: true
global_moran_test(wm_q_2022$no_cases,
                       wm_q_2022$nb,
                       wm_q_2022$wt,
                       zero.policy = TRUE,)
```

```{r}
#| code-fold: true
set.seed(1234) # To ensure reproducible
moran_mc_2022_res = global_moran_perm(wm_q_2022$no_cases,
                       wm_q_2022$nb,
                       wm_q_2022$wt,
                        nsim=999,
                       zero.policy = TRUE,)
moran_mc_2022_res
```

Similar to Year 2021, we can observed that the p-value is still smaller than 0.05 in the statistical test. Hence, we **have enough statistical evidence** to reject the null hypothesis that the spatial distribution of drug use case in Thailand are not resemble random distribution for Year 2022 and shows sign of **weak clustering**.

Lets check the summary statistics.

```{r}
#| code-fold: true
summary(moran_mc_2022_res$res[1:999])
```

To visualise the monte-carlo simulation, we can plot a histogram. The statistic I value for 2022 was 0.19 which fall under the alpha-value of the simulation result. As such, we can infer there is a weak sign of spatial autocorrelation in the drug use case across different locations.

```{r,fig.width=12,fig.height=10}
#| code-fold: true
ggplot() + 
  aes(moran_mc_2022_res$res[1:999]) + 
  geom_histogram(colour="black", fill="grey") +
  geom_vline(xintercept = 0, color = "red", linetype = "solid", size = 1) +
  labs(title = "Histogram of Simulated Moran's I For Thailand Drug Use Cases 2022",
       x = "Simulated Moran's I",
       y = "Frequency") +
  theme_minimal()
```
:::

```{r}
#| eval: false
write_rds(wm_q_2017,"data/rds/wm_q_2017.rds")
write_rds(wm_q_2018,"data/rds/wm_q_2018.rds")
write_rds(wm_q_2019,"data/rds/wm_q_2019.rds")
write_rds(wm_q_2020,"data/rds/wm_q_2020.rds")
write_rds(wm_q_2021,"data/rds/wm_q_2021.rds")
write_rds(wm_q_2022,"data/rds/wm_q_2022.rds")
```

## 4.2 Global Moran's I Test Overall Insight

::: callout-tip
## Overall Observation

-   Overall, we can observed that from the **Year 2017 to 2019**, the trend are increasing in term of I value and decreasing in p-value. But the p-value over the three years are still larger than the alpha value of 0.05. Hence, we **do not have enough statistical evidence** to reject the null hypothesis that the spatial distribution of drug use case in Thailand are resemble random distribution.

-   In the **Year** **2020**, the trend broke, with the I value decreasing instead of continuing to increase, and the p-value increasing instead of decreasing. This suggests a stronger indication of randomness in the distribution. I believe this change is due to COVID-19, which resulted in a decrease in recorded drug use cases.

-   In the Year 2021 - 2022, there are enough statistical evidence to reject the null hypothesis and we can infer that the spatial distribution of drug use cases **shows sign of weak clustering.**

-   Based on the histograms of the simulation results, we can observe that the distribution of the simulated Moran’s I values is predominantly skewed to the negative side, indicating that the data points exhibit a dispersed spatial pattern.
:::

## 4.3 Global Geary's C Test

In order to gain different insight into the spatial pattern of the drug use cases in Thailand. I will perform Global Geary's C as it focus more on local differences and more sensitive to local variability than Moran's I. Hence, it will be able to help to detect local variability and help in understand how strongly individual provinces deviate from the overall pattern in neighboring regions.

::: panel-tabset
## 2017

To performs Geary’s C test for spatial autocorrelation using [`global_c_test()`](https://sfdep.josiahparry.com/reference/global_c_test) from **sfdep** package.

```{r}
#| code-fold: true
global_c_test(wm_q_2017$no_cases,
              wm_q_2017$nb,
              wm_q_2017$wt,
              randomization = TRUE,
              allow_zero=TRUE)
```

To performs permutation test for Geary’s C statistic by using [`global_c_perm()`](https://sfdep.josiahparry.com/reference/global_c_perm) from **sfdep** packages.

```{r}
#| code-fold: true
set.seed(1234)
geary_mc_2017_res = global_c_perm(wm_q_2017$no_cases,
              wm_q_2017$nb,
              wm_q_2017$wt,
              nsim = 999,
              allow_zero = TRUE,)
geary_mc_2017_res
```

Based on the above actual and simulation statistic, with C = 1.0257, the drug use cases exhibits a slight tendency toward spatial dispersion, but the result is very close to 1, indicating near-randomness. The large simulated p-value(0.629) suggests that the spatial distribution is likely random, and there is **no significant evidence** of spatial autocorrelation in 2017.

To visvualising the Monte Carlo Geary's C.

```{r}
#| code-fold: true
summary(geary_mc_2017_res$res)
```

```{r,fig.width=12,fig.height=10}
#| code-fold: true
ggplot() + 
  aes(geary_mc_2017_res$res[1:999]) + 
  geom_histogram(colour="black", fill="grey") +
  geom_vline(xintercept = 1, color = "red", linetype = "solid", size = 1) +
  labs(title = "Histogram of Simulated  Geary C Values For Thailand Drug Use Cases 2017",
       x = "Simulated  Geary C",
       y = "Frequency") +
  theme_minimal()
```

## 2018

To performs Geary’s C test for spatial autocorrelation using [`global_c_test()`](https://sfdep.josiahparry.com/reference/global_c_test) from **sfdep** package.

```{r}
#| code-fold: true
global_c_test(wm_q_2018$no_cases,
              wm_q_2018$nb,
              wm_q_2018$wt,
              randomization = TRUE,
              allow_zero=TRUE)
```

To performs permutation test for Geary’s C statistic by using [`global_c_perm()`](https://sfdep.josiahparry.com/reference/global_c_perm) from **sfdep** packages.

```{r}
#| code-fold: true
set.seed(1234)
geary_mc_2018_res = global_c_perm(wm_q_2018$no_cases,
              wm_q_2018$nb,
              wm_q_2018$wt,
              nsim = 999,
              allow_zero = TRUE,)
geary_mc_2018_res
```

Based on the above actual and simulation statistic, with C = 1.0034 and simulated p-value are very similar to Year 2017. Hence, we ca infer there is **no significant evidence** of spatial autocorrelation in 2018 as well.

To visvualising the Monte Carlo Geary's C.

```{r}
#| code-fold: true
summary(geary_mc_2018_res$res)
```

```{r,fig.width=12,fig.height=10}
#| code-fold: true
ggplot() + 
  aes(geary_mc_2018_res$res[1:999]) + 
  geom_histogram(colour="black", fill="grey") +
  geom_vline(xintercept = 1, color = "red", linetype = "solid", size = 1) +
  labs(title = "Histogram of Simulated  Geary C Values For Thailand Drug Use Cases 2018",
       x = "Simulated  Geary C",
       y = "Frequency") +
  theme_minimal()
```

## 2019

To performs Geary’s C test for spatial autocorrelation using [`global_c_test()`](https://sfdep.josiahparry.com/reference/global_c_test) from **sfdep** package.

```{r}
#| code-fold: true
global_c_test(wm_q_2019$no_cases,
              wm_q_2019$nb,
              wm_q_2019$wt,
              randomization = TRUE,
              allow_zero=TRUE)
```

```{r}
#| code-fold: true
set.seed(1234)
geary_mc_2019_res = global_c_perm(wm_q_2019$no_cases,
              wm_q_2019$nb,
              wm_q_2019$wt,
              nsim = 999,
              allow_zero = TRUE,)
geary_mc_2019_res
```

Based on the above actual and simulation statistic, with C = 0.91638, the drug use cases exhibits a slight tendency **toward spatial clustered,** but the result is close to 1, indicating near-randomness. The simulated p-value(0.224) which is larger than the alpha-value 0.05, suggests that the spatial distribution is likely random, and there is **not enough significant evidence** of spatial autocorrelation in 2019.

To visvualising the Monte Carlo Geary's C.

```{r}
#| code-fold: true
summary(geary_mc_2019_res$res)
```

```{r,fig.width=12,fig.height=10}
#| code-fold: true
ggplot() + 
  aes(geary_mc_2019_res$res[1:999]) + 
  geom_histogram(colour="black", fill="grey") +
  geom_vline(xintercept = 1, color = "red", linetype = "solid", size = 1) +
  labs(title = "Histogram of Simulated  Geary C Values For Thailand Drug Use Cases 2019",
       x = "Simulated  Geary C",
       y = "Frequency") +
  theme_minimal()
```

## 2020

To performs Geary’s C test for spatial autocorrelation using [`global_c_test()`](https://sfdep.josiahparry.com/reference/global_c_test) from **sfdep** package.

```{r}
#| code-fold: true
global_c_test(wm_q_2020$no_cases,
              wm_q_2020$nb,
              wm_q_2020$wt,
              randomization = TRUE,
              allow_zero=TRUE)
```

To performs permutation test for Geary’s C statistic by using [`global_c_perm()`](https://sfdep.josiahparry.com/reference/global_c_perm) from **sfdep** packages.

```{r}
#| code-fold: true
set.seed(1234)
geary_mc_2020_res = global_c_perm(wm_q_2020$no_cases,
              wm_q_2020$nb,
              wm_q_2020$wt,
              nsim = 999,
              allow_zero = TRUE,)
geary_mc_2020_res
```

Based on the above actual and simulation statistic, with C = 0.95237 and the simulated p-value(0.324) similar to previous year (2020) suggests the drug use cases exhibits a slight tendency **toward spatial clustered** and the spatial distribution is likely random, and there is **not enough significant evidence** of spatial autocorrelation in 2020.

To visvualising the Monte Carlo Geary's C.

```{r}
#| code-fold: true
summary(geary_mc_2020_res$res)
```

```{r,fig.width=12,fig.height=10}
#| code-fold: true
ggplot() + 
  aes(geary_mc_2020_res$res[1:999]) + 
  geom_histogram(colour="black", fill="grey") +
  geom_vline(xintercept = 1, color = "red", linetype = "solid", size = 1) +
  labs(title = "Histogram of Simulated  Geary C Values For Thailand Drug Use Cases 2020",
       x = "Simulated  Geary C",
       y = "Frequency") +
  theme_minimal()
```

## 2021

To performs Geary’s C test for spatial autocorrelation using [`global_c_test()`](https://sfdep.josiahparry.com/reference/global_c_test) from **sfdep** package.

```{r}
#| code-fold: true
global_c_test(wm_q_2021$no_cases,
              wm_q_2021$nb,
              wm_q_2021$wt,
              randomization = TRUE,
              allow_zero=TRUE)
```

To performs permutation test for Geary’s C statistic by using [`global_c_perm()`](https://sfdep.josiahparry.com/reference/global_c_perm) from **sfdep** packages.

```{r}
#| code-fold: true
set.seed(1234)
geary_mc_2021_res = global_c_perm(wm_q_2021$no_cases,
              wm_q_2021$nb,
              wm_q_2021$wt,
              nsim = 999,
              allow_zero = TRUE,)
geary_mc_2021_res
```

Based on the above actual and simulation statistic, with C = **0.84383** and actual p-value of **0.03476**, the drug use cases exhibits a slight tendency **toward spatial clustered** and we **can reject the null hypothesis** that the autocorrelation is unlikely to have occurred by random. However,the simulated p-value(**0.061**) which is larger than the alpha-value 0.05.

The difference between the actual p-value (0.034) and the simulated p-value (0.061) indicates that while the traditional test suggests **significant spatial clustering**, the Monte Carlo simulation shows **weaker evidence** for rejecting the null hypothesis of spatial randomness.

To visvualising the Monte Carlo Geary's C.

```{r}
#| code-fold: true
summary(geary_mc_2021_res$res)
```

```{r,fig.width=12,fig.height=10}
#| code-fold: true
ggplot() + 
  aes(geary_mc_2021_res$res[1:999]) + 
  geom_histogram(colour="black", fill="grey") +
  geom_vline(xintercept = 1, color = "red", linetype = "solid", size = 1) +
  labs(title = "Histogram of Simulated  Geary C Values For Thailand Drug Use Cases 2021",
       x = "Simulated  Geary C",
       y = "Frequency") +
  theme_minimal()
```

## 2022

To performs Geary’s C test for spatial autocorrelation using [`global_c_test()`](https://sfdep.josiahparry.com/reference/global_c_test) from **sfdep** package.

```{r}
#| code-fold: true
global_c_test(wm_q_2022$no_cases,
              wm_q_2022$nb,
              wm_q_2022$wt,
              randomization = TRUE,
              allow_zero=TRUE)
```

To performs permutation test for Geary’s C statistic by using [`global_c_perm()`](https://sfdep.josiahparry.com/reference/global_c_perm) from **sfdep** packages.

```{r}
#| code-fold: true
set.seed(1234)
geary_mc_2022_res = global_c_perm(wm_q_2022$no_cases,
              wm_q_2022$nb,
              wm_q_2022$wt,
              nsim = 999,
              allow_zero = TRUE,)
geary_mc_2022_res
```

Based on the above actual and simulation statistic, unlike previous year(2021), with C = **0.83723** suggesting the drug use cases exhibits a slight tendency **toward spatial clustered.** With actual p-value of **0.2626** and simulated p-value of **0.046**, both is smaller than the alpha-value 0.05, hence, we **can reject the null hypothesis** that the autocorrelation is unlikely to have occurred by random and infer there is spatial autocorrelation of clustering in 2022.

To visvualising the Monte Carlo Geary's C.

```{r}
#| code-fold: true
summary(geary_mc_2022_res$res)
```

```{r,fig.width=12,fig.height=10}
#| code-fold: true
ggplot() + 
  aes(geary_mc_2022_res$res[1:999]) + 
  geom_histogram(colour="black", fill="grey") +
  geom_vline(xintercept = 1, color = "red", linetype = "solid", size = 1) +
  labs(title = "Histogram of Simulated  Geary C Values For Thailand Drug Use Cases 2022",
       x = "Simulated  Geary C",
       y = "Frequency") +
  theme_minimal()
```
:::

## 4.4 Global Geary's Test Overall Insight

::: callout-tip
## Overall Observation

-   Overall, the trend of what we have observed from Global Geary's test is similar to Global Moran's I Test. Except for Year 2021.

-   **Year 2017 to 2019**, decreasing trend in C value and p-value.

-   **Year 2020**, instead of continuing decreasing, both C value and p-value increased.

-   However**, for Year 2021**, the C value and actual p-value suggest spatial clustered and we can reject the null hypothesis, but the simulated p-value become larger than alpha-value of 0.05, which shows weak evidence for us to reject the null hypothesis.

-   **Year 2022**, There is sufficient statistical evidence for us to reject the null hypothesis and conclude that there is spatial autocorrelation indicating clustering.
:::

# 5. Local Measures of Spatial Autocorrelation

## 5.1 Local Moran's I Test

As there are 3 p-value fields, for consistency, I will use **p_ii_sim** field, since I will simulate 1000 times and it will help in ensure robustness in my finding

::: panel-tabset
## 2017

```{r}
#| code-fold: true
set.seed(1234)
lisa_2017 <- wm_q_2017 %>% 
  mutate(local_moran = local_moran(
    no_cases, nb, wt, nsim = 999,zero.policy = TRUE),
         .before = 1) %>%
  unnest(local_moran)
```

To visualise local Moran's I and p-value.

```{r,fig.width=12,fig.height=10}
#| code-fold: true
tmap_mode("plot")
map1 <- tm_shape(lisa_2017) +
  tm_fill("ii",
          style = "pretty",
          palette = "BrBG",
          title = "local moran statistics") + 
  tm_borders(alpha = 0.5) +
  tm_view(set.zoom.limits = c(6,8)) +
  tm_layout(main.title = "local Moran's I of Drug Use Cases in 2017",
            main.title.size = 0.8)

map2 <- tm_shape(lisa_2017) +
  tm_fill("p_ii_sim",
          breaks = c(0, 0.001, 0.01, 0.05, 1),
              labels = c("0.001", "0.01", "0.05", "Not sig")) + 
  tm_borders(alpha = 0.5) +
  tm_layout(main.title = "p-value of local Moran's I in 2017",
            main.title.size = 0.8)
tmap_arrange(map1, map2, ncol = 2)
```

We can observe that the area around Bangkok contains local outliers, as the number of cases in Bangkok is significantly higher than in the surrounding areas, which have relatively low case numbers. Additionally, there are three provinces on the northern side of Bangkok that exhibit local clustering.

## 2018

```{r}
#| code-fold: true
set.seed(1234)
lisa_2018 <- wm_q_2018 %>% 
  mutate(local_moran = local_moran(
    no_cases, nb, wt, nsim = 999,zero.policy = TRUE),
         .before = 1) %>%
  unnest(local_moran)
```

To visualise local Moran's I and p-value.

```{r,fig.width=12,fig.height=10}
#| code-fold: true
tmap_mode("plot")
map1 <- tm_shape(lisa_2018) +
  tm_fill("ii",
          style = "pretty",
          palette = "BrBG",
          title = "local moran statistics") + 
  tm_borders(alpha = 0.5) +
  tm_view(set.zoom.limits = c(6,8)) +
  tm_layout(main.title = "local Moran's I of Drug Use Cases in 2018",
            main.title.size = 0.8)

map2 <- tm_shape(lisa_2018) +
  tm_fill("p_ii_sim",
          breaks = c(0, 0.001, 0.01, 0.05, 1),
              labels = c("0.001", "0.01", "0.05", "Not sig")) + 
  tm_borders(alpha = 0.5) +
  tm_layout(main.title = "p-value of local Moran's I in 2018",
            main.title.size = 0.8)

tmap_arrange(map1, map2, ncol = 2)

```

We can see that the some provinces( Samut Prakan,Chachoengsao) near Bangkok have p_ii_sim values are below the alpha level of 0.05, with nearly being positive for the I value, except for Samut Sakhon(left side of Bangkok) and Nonthaburi(top side of Bangkok), which has a negative I value, indicating it being the outlier.

## 2019

```{r}
#| code-fold: true
set.seed(1234)
lisa_2019 <- wm_q_2019 %>% 
  mutate(local_moran = local_moran(
    no_cases, nb, wt, nsim = 999,zero.policy = TRUE),
         .before = 1) %>%
  unnest(local_moran)
```

To visualise local Moran's I and p-value.

```{r,fig.width=12,fig.height=10}
#| code-fold: true
tmap_mode("plot")
map1 <- tm_shape(lisa_2019) +
  tm_fill("ii",
          style = "pretty",
          palette = "BrBG",
          title = "local moran statistics") + 
  tm_borders(alpha = 0.5) +
  tm_view(set.zoom.limits = c(6,8)) +
  tm_layout(main.title = "local Moran's I of Drug Use Cases in 2019",
            main.title.size = 0.8)

map2 <- tm_shape(lisa_2019) +
  tm_fill("p_ii_sim",
          breaks = c(0, 0.001, 0.01, 0.05, 1),
              labels = c("0.001", "0.01", "0.05", "Not sig")) + 
  tm_borders(alpha = 0.5) +
  tm_layout(main.title = "p-value of local Moran's I in 2019",
            main.title.size = 0.8)

tmap_arrange(map1, map2, ncol = 2)
```

We can observed that the drug use cases in 2019 , is quite similar to previous year (2018), except that Samut Sakhon is no longer an outlier. And we have two province on top of the northern side.

## 2020

```{r}
#| code-fold: true
set.seed(1234)
lisa_2020 <- wm_q_2020 %>% 
  mutate(local_moran = local_moran(
    no_cases, nb, wt, nsim = 999,zero.policy = TRUE),
         .before = 1) %>%
  unnest(local_moran)
```

To visualise local Moran's I and p-value.

```{r,fig.width=12,fig.height=10}
#| code-fold: true
tmap_mode("plot")
map1 <- tm_shape(lisa_2020) +
  tm_fill("ii",
          style = "pretty",
          palette = "BrBG",
          title = "local moran statistics") + 
  tm_borders(alpha = 0.5) +
  tm_view(set.zoom.limits = c(6,8)) +
  tm_layout(main.title = "local Moran's I of Drug Use Cases in 2020",
            main.title.size = 0.8)

map2 <- tm_shape(lisa_2020) +
  tm_fill("p_ii_sim",
          breaks = c(0, 0.001, 0.01, 0.05, 1),
              labels = c("0.001", "0.01", "0.05", "Not sig")) + 
  tm_borders(alpha = 0.5) +
  tm_layout(main.title = "p-value of local Moran's I in 2020",
            main.title.size = 0.8)

tmap_arrange(map1, map2, ncol = 2)
```

From the map, we can observe that there are not many significant changes compared to previous years, except for one province in the central become a weak cluster(I value = 0 to 1).

## 2021

```{r}
#| code-fold: true
set.seed(1234)
lisa_2021 <- wm_q_2021 %>% 
  mutate(local_moran = local_moran(
    no_cases, nb, wt, nsim = 999,zero.policy = TRUE),
         .before = 1) %>%
  unnest(local_moran)
```

To visualise local Moran's I and p-value.

```{r,fig.width=12,fig.height=10}
#| code-fold: true
tmap_mode("plot")
map1 <- tm_shape(lisa_2021) +
  tm_fill("ii",
          style = "pretty",
          palette = "BrBG",
          title = "local moran statistics") + 
  tm_borders(alpha = 0.5) +
  tm_view(set.zoom.limits = c(6,8)) +
  tm_layout(main.title = "local Moran's I of Drug Use Cases in 2021",
            main.title.size = 0.8)

map2 <- tm_shape(lisa_2021) +
  tm_fill("p_ii_sim",
          breaks = c(0, 0.001, 0.01, 0.05, 1),
              labels = c("0.001", "0.01", "0.05", "Not sig")) + 
  tm_borders(alpha = 0.5) +
  tm_layout(main.title = "p-value of local Moran's I in 2021",
            main.title.size = 0.8)

tmap_arrange(map1, map2, ncol = 2)

```

Based on the above plots,we can see a cluster at the western region.

## 2022

```{r}
#| code-fold: true
set.seed(1234)
lisa_2022 <- wm_q_2022 %>% 
  mutate(local_moran = local_moran(
    no_cases, nb, wt, nsim = 999,zero.policy = TRUE),
         .before = 1) %>%
  unnest(local_moran)
```

To visualise local Moran's I and p-value.

```{r,fig.width=12,fig.height=10}
#| code-fold: true
tmap_mode("plot")
map1 <- tm_shape(lisa_2022) +
  tm_fill("ii",
          style = "pretty",
          palette = "BrBG",
          title = "local moran statistics") + 
  tm_borders(alpha = 0.5) +
  tm_view(set.zoom.limits = c(6,8)) +
  tm_layout(main.title = "local Moran's I of Drug Use Cases in 2022",
            main.title.size = 0.8)

map2 <- tm_shape(lisa_2022) +
  tm_fill("p_ii_sim",
          breaks = c(0, 0.001, 0.01, 0.05, 1),
              labels = c("0.001", "0.01", "0.05", "Not sig")) + 
  tm_borders(alpha = 0.5) +
  tm_layout(main.title = "p-value of local Moran's I in 2022",
            main.title.size = 0.8)

tmap_arrange(map1, map2, ncol = 2)
```

The plots for 2022 reveal distinct clustering areas in both the Northeast and Central regions, characterized by predominantly positive I values and p-values below the alpha threshold of 0.05. Additionally, there are two notable outliers: one located in the southern region and another in the northeastern region adjacent to the cluster.
:::

::: callout-tip
## Overall Insight

-   From **2017 to 2020,** the p-values below 0.05 are primarily concentrated near the Bangkok area and central region, indicating that outliers (with negative I values) and clusters (with positive I values) are likely located in this region.

-   In **2021** and **2022**, there are clear sign of clustering and in 2022, there are two outliers as well.
:::

## 5.2 Local Indicators of Spatial Association(LISA)

We can utilize the LISA Cluster Map to highlight statistically significant areas, making it easier to identify spatial autocorrelation patterns in the data.

After examining the skewness of the LISA for each year, the distribution of skewness appears to be **negatively skewed** (left side has more values than the positive side). Therefore, I will use the **median** for the LISA map analysis and filter by **p_ii_sim** value.

```{r,fig.width=12,fig.height=10}
#| code-fold: true
library(gridExtra)

plot_2017 <- ggplot(lisa_2017, aes(x = skewness)) + 
  geom_histogram(colour = "black", fill = "grey", bins = 30) +
  labs(x = "Skewness", y = "Frequency", title = "Skewness in 2017") +
  theme_minimal()

plot_2018 <- ggplot(lisa_2018, aes(x = skewness)) + 
  geom_histogram(colour = "black", fill = "grey", bins = 30) +
  labs(x = "Skewness", y = "Frequency", title = "Skewness in 2018") +
  theme_minimal()

plot_2019 <- ggplot(lisa_2019, aes(x = skewness)) + 
  geom_histogram(colour = "black", fill = "grey", bins = 30) +
  labs(x = "Skewness", y = "Frequency", title = "Skewness in 2019") +
  theme_minimal()

plot_2020 <- ggplot(lisa_2020, aes(x = skewness)) + 
  geom_histogram(colour = "black", fill = "grey", bins = 30) +
  labs(x = "Skewness", y = "Frequency", title = "Skewness in 2020") +
  theme_minimal()

plot_2021 <- ggplot(lisa_2021, aes(x = skewness)) + 
  geom_histogram(colour = "black", fill = "grey", bins = 30) +
  labs(x = "Skewness", y = "Frequency", title = "Skewness in 2021") +
  theme_minimal()

plot_2022 <- ggplot(lisa_2022, aes(x = skewness)) + 
  geom_histogram(colour = "black", fill = "grey", bins = 30) +
  labs(x = "Skewness", y = "Frequency", title = "Skewness in 2022") +
  theme_minimal()

# Arrange all six plots in a 2-column, 3-row layout
grid.arrange(plot_2017, plot_2018, plot_2019, plot_2020, plot_2021, plot_2022, ncol = 2, nrow = 3)
```

Local Indicators of Spatial Association(LISA) interpretation:

-   Clusters

    -   **High-High**: High value area, surrounded by high value neighbours.

    -   **Low-Low**: Low value area, surrounded by low value neightbours.

-   Outliers

    -   **High-Low**: High value area, surrounded by low value neighbours.

    -   **Low-High**: Low value area, surrounded by high value neighbours.

Below is the code chunk that visualizes the LISA map alongside the drug use case map. I found this side-by-side comparison particularly useful for providing additional context, helping to better understand why specific locations are classified as clusters or outliers.

::: panel-tabset
## 2017

```{r,fig.width=12,fig.height=12}
#| code-fold: true
lisa_sig_2017 <- lisa_2017  %>%
  filter(p_ii_sim < 0.05)
map1 <- tm_shape(lisa_2017) +
  tm_polygons() +
  tm_borders(alpha = 0.5) +
tm_shape(lisa_sig_2017) +
  tm_fill("median") + 
  tm_borders(alpha = 0.4)

map2 <- tm_shape(lisa_2017) +
  tm_polygons("no_cases",
          palette = "Blues",
          style="quantile", n=10)

tmap_arrange(map1, map2,ncol=2)

```

## 2018

```{r,fig.width=12,fig.height=10}
#| code-fold: true
lisa_sig_2018 <- lisa_2018  %>%
  filter(p_ii_sim < 0.05)

map1 <- tm_shape(lisa_2018) +
  tm_polygons() +
  tm_borders(alpha = 0.5) +
tm_shape(lisa_sig_2018) +
  tm_fill("median") + 
  tm_borders(alpha = 0.4)

map2 <- tm_shape(lisa_2018) +
  tm_polygons("no_cases",
          palette = "Blues",
          style="quantile", n=10)

tmap_arrange(map1, map2,ncol=2)
```

## 2019

```{r,fig.width=12,fig.height=10}
#| code-fold: true
lisa_sig_2019 <- lisa_2019  %>%
  filter(p_ii_sim < 0.05)

map1 <- tm_shape(lisa_2019) +
  tm_polygons() +
  tm_borders(alpha = 0.5) +
tm_shape(lisa_sig_2019) +
  tm_fill("median") + 
  tm_borders(alpha = 0.4)

map2 <- tm_shape(lisa_2019) +
  tm_polygons("no_cases",
          palette = "Blues",
          style="quantile", n=10)

tmap_arrange(map1, map2,ncol=2)
```

## 2020

```{r,fig.width=12,fig.height=10}
#| code-fold: true
lisa_sig_2020 <- lisa_2020  %>%
  filter(p_ii_sim < 0.05)

map1 <- tm_shape(lisa_2020) +
  tm_polygons() +
  tm_borders(alpha = 0.5) +
tm_shape(lisa_sig_2020) +
  tm_fill("median") + 
  tm_borders(alpha = 0.4)

map2 <- tm_shape(lisa_2020) +
  tm_polygons("no_cases",
          palette = "Blues",
          style="quantile", n=10)

tmap_arrange(map1, map2,ncol=2)
```

## 2021

```{r,fig.width=12,fig.height=10}
#| code-fold: true
lisa_sig_2021 <- lisa_2021  %>%
  filter(p_ii_sim < 0.05)

map1 <- tm_shape(lisa_2021) +
  tm_polygons() +
  tm_borders(alpha = 0.5) +
tm_shape(lisa_sig_2021) +
  tm_fill("median") + 
  tm_borders(alpha = 0.4)

map2 <- tm_shape(lisa_2021) +
  tm_polygons("no_cases",
          palette = "Blues",
          style="quantile", n=10)

tmap_arrange(map1, map2,ncol=2)
```

## 2022

```{r,fig.width=12,fig.height=10}
#| code-fold: true
lisa_sig_2022 <- lisa_2022  %>%
  filter(p_ii_sim < 0.05)

map1 <- tm_shape(lisa_2022) +
  tm_polygons() +
  tm_borders(alpha = 0.5) +
tm_shape(lisa_sig_2022) +
  tm_fill("median") + 
  tm_borders(alpha = 0.4)

map2 <- tm_shape(lisa_2022) +
  tm_polygons("no_cases",
          palette = "Blues",
          style="quantile", n=10)

tmap_arrange(map1, map2, ncol=2)

```
:::

::: callout-note
## LISA Insight

-   The LISA map provides a much clearer way to identify clusters, particularly distinguishing between high-value and low-value clusters. This approach simplifies the process compared to the Local Moran's I Test maps we plotted earlier, which required multiple maps and side-by-side comparisons to interpret the spatial patterns. With LISA, clusters are more visually intuitive, making it easier to draw insights from spatial autocorrelation.
-   Note that since I am using the **median** instead of the **mean**, some provinces in the LISA map appear slightly different from the Local Moran's I test p-value map. I think the difference arises because the median is more robust to skewed data, which may influence the spatial patterns displayed.
:::

## 5.3 Hot Spot and Code Spot Area Analysis(HCSA) with local Gi\*

Beside LISA, we can use local Gi\* statistic to detect hot spots (areas of high values surrounded by high values) and cold spots (areas of low values surrounded by low values). In this analysis, spatial clustering patterns are measured, and locations are classified as hot spots, cold spots, or neutral areas. I will be use local Gi\*, which will consider itself.

::: callout-warning
This analysis is not to identify outliers and need to use distance matrix with all positive value.
:::

In the previous sections, I used queen contiguity to define neighbors. Since there are multiple methods for calculating neighbors, I will explore different approaches using the 2017 data to identify the most suitable one for our analysis using HCSA and to gain diverse insights. For the weights, I will continue utilizing `st_inverse_distance`.

-   Queen Contiguity =\> st_contiguity

-   Neighbors from a distance =\> st_dist_band

-   K-Nearest Neighbors =\> st_knn

First, we need to derive a spatial weight matrix before computing the local Gi\* statistics. As the local Gi\* statistic requires a distance matrix, we use the distance matrix for this purpose.

Since the geometry field in `drug_use_cases` contains multipolygons instead of polygons, I will apply `st_centroid` to extract the central points for each multipolygon. This ensures we can calculate the distances between these central points accurately for the analysis.

::: panel-tabset
## 2017 - Queen Contiguity

Below code chunk will compute spatial weight matrix.

```{r}
#| code-fold: true
wm_idw_2017 <- drug_use_cases %>%
  filter(fiscal_year == 2017) %>%
  mutate(nb = include_self(st_contiguity(geometry)),
         geometry_centroid = st_centroid(geometry), 
         wts = st_inverse_distance(nb, 
                              geometry_centroid, 
                              scale = 1,
                              alpha = 1),
         .before = 1)

```

To compute the local G\* and using **set.seed()** to ensure the computation is reproducible.

```{r}
#| code-fold: true
set.seed(1234)
HCSA_2017 <- wm_idw_2017 %>% 
  mutate(local_Gi = local_gstar_perm(
    no_cases, nb, wts, nsim = 999),
         .before = 1) %>%
  unnest(local_Gi)

```

Visualising Gi\* and p_sim value using tmap at province level.

```{r,fig.width=12,fig.height=10}
#| code-fold: true
tmap_mode("plot")
map1 <- tm_shape(HCSA_2017) +
  tm_fill("gi_star") + 
  tm_borders(alpha = 0.5) +
  tm_view(set.zoom.limits = c(6,8)) +
  tm_layout(main.title = "Gi* of Drug Use Cases in 2017",
            main.title.size = 0.8)

map2 <- tm_shape(HCSA_2017) +
  tm_fill("p_sim",
          breaks = c(0, 0.001, 0.01, 0.05, 1),
              labels = c("0.001", "0.01", "0.05", "Not sig")) + 
  tm_borders(alpha = 0.5) +
  tm_layout(main.title = "p-value of Gi*",
            main.title.size = 0.8)

tmap_arrange(map1, map2, ncol = 2)
```

Visualising the significant(p_sim \< 0.05) HCSA map.

```{r,fig.width=12,fig.height=10}
#| code-fold: true
HCSA_sig_2017 <- HCSA_2017  %>%
  filter(p_sim < 0.05)

map1 <- tm_shape(HCSA_2017) +
  tm_polygons() +
  tm_borders(alpha = 0.5) +
tm_shape(HCSA_sig_2017) +
  tm_fill("cluster") + 
  tm_borders(alpha = 0.4)

map2 <- tm_shape(HCSA_2017) +
  tm_polygons("no_cases",
          palette = "Blues",
          style="quantile", n=10)

tmap_arrange(map1, map2,ncol=2)
```

## 2017 - Neighbors from a distance

Below code chunk will compute spatial weight matrix.

```{r}
#| code-fold: true
wm_idw_2017_db <- drug_use_cases %>%
  filter(fiscal_year == 2017) %>%
  mutate(nb = include_self(st_dist_band(geometry, lower=0)),
         geometry_centroid = st_centroid(geometry), 
         wts = st_inverse_distance(nb, 
                              geometry_centroid, 
                              scale = 1,
                              alpha = 1),
         .before = 1)

```

To compute the local G\* and using **set.seed()** to ensure the computation is reproducible.

```{r}
#| code-fold: true
set.seed(1234)
HCSA_2017_db <- wm_idw_2017_db %>% 
  mutate(local_Gi = local_gstar_perm(
    no_cases, nb, wts, nsim = 999),
         .before = 1) %>%
  unnest(local_Gi)

```

Visualising Gi\* and p_sim value using tmap at province level.

```{r,fig.width=12,fig.height=10}
#| code-fold: true
tmap_mode("plot")
map1 <- tm_shape(HCSA_2017_db) +
  tm_fill("gi_star") + 
  tm_borders(alpha = 0.5) +
  tm_view(set.zoom.limits = c(6,8)) +
  tm_layout(main.title = "Gi* of Drug Use Cases in 2017",
            main.title.size = 0.8)

map2 <- tm_shape(HCSA_2017_db) +
  tm_fill("p_sim",
          breaks = c(0, 0.001, 0.01, 0.05, 1),
              labels = c("0.001", "0.01", "0.05", "Not sig")) + 
  tm_borders(alpha = 0.5) +
  tm_layout(main.title = "p-value of Gi*",
            main.title.size = 0.8)

tmap_arrange(map1, map2, ncol = 2)
```

Visualising the significant(p_sim \< 0.05) HCSA map.

```{r,fig.width=12,fig.height=10}
#| code-fold: true
HCSA_sig_2017_db <- HCSA_2017_db  %>%
  filter(p_sim < 0.05)

map1 <- tm_shape(HCSA_2017_db) +
  tm_polygons() +
  tm_borders(alpha = 0.5) +
tm_shape(HCSA_sig_2017_db) +
  tm_fill("cluster") + 
  tm_borders(alpha = 0.4)

map2 <- tm_shape(HCSA_2017_db) +
  tm_polygons("no_cases",
          palette = "Blues",
          style="quantile", n=10)

tmap_arrange(map1, map2,ncol=2)
```

## 2017 - K-Nearest Neighbors

Below code chunk will compute spatial weight matrix.

```{r}
#| code-fold: true
wm_idw_2017_k <- drug_use_cases %>%
  filter(fiscal_year == 2017) %>%
  mutate(nb = include_self(st_knn(geometry, k = 8)),
         geometry_centroid = st_centroid(geometry), 
         wts = st_inverse_distance(nb, 
                              geometry_centroid,
                              scale = 1,
                              alpha = 1),
         .before = 1)

```

To compute the local G\* and using **set.seed()** to ensure the computation is reproducible.

```{r}
#| code-fold: true
set.seed(1234)
HCSA_2017_k <- wm_idw_2017_k %>% 
  mutate(local_Gi = local_gstar_perm(
    no_cases, nb, wts, nsim = 999),
         .before = 1) %>%
  unnest(local_Gi)

```

Visualising Gi\* and p_sim value using tmap at province level.

```{r,fig.width=12,fig.height=10}
#| code-fold: true
tmap_mode("plot")
map1 <- tm_shape(HCSA_2017_k) +
  tm_fill("gi_star") + 
  tm_borders(alpha = 0.5) +
  tm_view(set.zoom.limits = c(6,8)) +
  tm_layout(main.title = "Gi* of Drug Use Cases in 2017",
            main.title.size = 0.8)

map2 <- tm_shape(HCSA_2017_k) +
  tm_fill("p_sim",
          breaks = c(0, 0.001, 0.01, 0.05, 1),
              labels = c("0.001", "0.01", "0.05", "Not sig")) + 
  tm_borders(alpha = 0.5) +
  tm_layout(main.title = "p-value of Gi*",
            main.title.size = 0.8)

tmap_arrange(map1, map2, ncol = 2)
```

Visualising the significant(p_sim \< 0.05) HCSA map.

```{r,fig.width=12,fig.height=10}
#| code-fold: true
HCSA_sig_2017_k <- HCSA_2017_k  %>%
  filter(p_sim < 0.05)

map1 <- tm_shape(HCSA_2017_k) +
  tm_polygons() +
  tm_borders(alpha = 0.5) +
tm_shape(HCSA_sig_2017_k) +
  tm_fill("cluster") + 
  tm_borders(alpha = 0.4)

map2 <- tm_shape(HCSA_2017_k) +
  tm_polygons("no_cases",
          palette = "Blues",
          style="quantile", n=10)

tmap_arrange(map1, map2,ncol=2)
```
:::

::: callout-tip
-   Notice that for the HCSA map for Queen Contiguity, is actually every similar with what we have in LISA map, because of the same method on how we define neighbors.

-   For distance-based neighbors, I am using the default upper threshold. From the plot, we can observe that some areas lose local context. For example, the three provinces at the right side of Bangkok all have relatively high `no_cases`, yet one of them is not identified as part of the high cluster.

-   For K-Nearest Neighbors (KNN), the plot accurately represents the central region. However, a potential issue with KNN is that it disregards local context, as it doesn't account for whether neighboring provinces are adjacent. For instance, in the southern region, the provinces are arranged in a line, meaning that using KNN may select neighbors that are quite distant from the province itself. This can result in weaker or misleading spatial autocorrelation patterns.

-   Hence, for the years 2018 to 2022, I will continue using Queen Contiguity to identify neighbors, as it considers all adjacent neighbors, providing a more precise representation of local spatial relationships.
:::

::: panel-tabset
## 2018

Below code chunk will compute spatial weight matrix.

```{r}
#| code-fold: true
wm_idw_2018 <- drug_use_cases %>%
  filter(fiscal_year == 2018) %>%
  mutate(nb = include_self(st_contiguity(geometry)),
         geometry_centroid = st_centroid(geometry), 
         wts = st_inverse_distance(nb, 
                              geometry_centroid, 
                              scale = 1,
                              alpha = 1),
         .before = 1)

```

To compute the local G\* and using **set.seed()** to ensure the computation is reproducible.

```{r}
#| code-fold: true
set.seed(1234)
HCSA_2018 <- wm_idw_2018 %>% 
  mutate(local_Gi = local_gstar_perm(
    no_cases, nb, wts, nsim = 999),
         .before = 1) %>%
  unnest(local_Gi)

```

Visualising Gi\* and p_sim value using tmap at province level.

```{r,fig.width=12,fig.height=10}
#| code-fold: true
tmap_mode("plot")
map1 <- tm_shape(HCSA_2018) +
  tm_fill("gi_star") + 
  tm_borders(alpha = 0.5) +
  tm_view(set.zoom.limits = c(6,8)) +
  tm_layout(main.title = "Gi* of Drug Use Cases in 2018",
            main.title.size = 0.8)

map2 <- tm_shape(HCSA_2018) +
  tm_fill("p_sim",
          breaks = c(0, 0.001, 0.01, 0.05, 1),
              labels = c("0.001", "0.01", "0.05", "Not sig")) + 
  tm_borders(alpha = 0.5) +
  tm_layout(main.title = "p-value of Gi*",
            main.title.size = 0.8)

tmap_arrange(map1, map2, ncol = 2)
```

Visualising the significant(p_sim \< 0.05) HCSA map.

```{r,fig.width=12,fig.height=10}
#| code-fold: true
HCSA_sig_2018 <- HCSA_2018  %>%
  filter(p_sim < 0.05)

map1 <- tm_shape(HCSA_2018) +
  tm_polygons() +
  tm_borders(alpha = 0.5) +
tm_shape(HCSA_sig_2018) +
  tm_fill("cluster") + 
  tm_borders(alpha = 0.4)

map2 <- tm_shape(HCSA_2018) +
  tm_polygons("no_cases",
          palette = "Blues",
          style="quantile", n=10)

tmap_arrange(map1, map2,ncol=2)
```

## 2019

Below code chunk will compute spatial weight matrix.

```{r}
#| code-fold: true
wm_idw_2019 <- drug_use_cases %>%
  filter(fiscal_year == 2019) %>%
  mutate(nb = include_self(st_contiguity(geometry)),
         geometry_centroid = st_centroid(geometry), 
         wts = st_inverse_distance(nb, 
                              geometry_centroid, 
                              scale = 1,
                              alpha = 1),
         .before = 1)

```

To compute the local G\* and using **set.seed()** to ensure the computation is reproducible.

```{r}
#| code-fold: true
set.seed(1234)
HCSA_2019 <- wm_idw_2019 %>% 
  mutate(local_Gi = local_gstar_perm(
    no_cases, nb, wts, nsim = 999),
         .before = 1) %>%
  unnest(local_Gi)

```

Visualising Gi\* and p_sim value using tmap at province level.

```{r,fig.width=12,fig.height=10}
#| code-fold: true
tmap_mode("plot")
map1 <- tm_shape(HCSA_2019) +
  tm_fill("gi_star") + 
  tm_borders(alpha = 0.5) +
  tm_view(set.zoom.limits = c(6,8)) +
  tm_layout(main.title = "Gi* of Drug Use Cases in 2019",
            main.title.size = 0.8)

map2 <- tm_shape(HCSA_2019) +
  tm_fill("p_sim",
          breaks = c(0, 0.001, 0.01, 0.05, 1),
              labels = c("0.001", "0.01", "0.05", "Not sig")) + 
  tm_borders(alpha = 0.5) +
  tm_layout(main.title = "p-value of Gi*",
            main.title.size = 0.8)

tmap_arrange(map1, map2, ncol = 2)
```

Visualising the significant(p_sim \< 0.05) HCSA map.

```{r,fig.width=12,fig.height=10}
#| code-fold: true
HCSA_sig_2019 <- HCSA_2019  %>%
  filter(p_sim < 0.05)

map1 <- tm_shape(HCSA_2019) +
  tm_polygons() +
  tm_borders(alpha = 0.5) +
tm_shape(HCSA_sig_2019) +
  tm_fill("cluster") + 
  tm_borders(alpha = 0.4)

map2 <- tm_shape(HCSA_2019) +
  tm_polygons("no_cases",
          palette = "Blues",
          style="quantile", n=10)

tmap_arrange(map1, map2,ncol=2)
```

## 2020

Below code chunk will compute spatial weight matrix.

```{r}
#| code-fold: true
wm_idw_2020 <- drug_use_cases %>%
  filter(fiscal_year == 2020) %>%
  mutate(nb = include_self(st_contiguity(geometry)),
         geometry_centroid = st_centroid(geometry), 
         wts = st_inverse_distance(nb, 
                              geometry_centroid, 
                              scale = 1,
                              alpha = 1),
         .before = 1)

```

To compute the local G\* and using **set.seed()** to ensure the computation is reproducible.

```{r}
#| code-fold: true
set.seed(1234)
HCSA_2020 <- wm_idw_2020 %>% 
  mutate(local_Gi = local_gstar_perm(
    no_cases, nb, wts, nsim = 999),
         .before = 1) %>%
  unnest(local_Gi)

```

Visualising Gi\* and p_sim value using tmap at province level.

```{r,fig.width=12,fig.height=10}
#| code-fold: true
tmap_mode("plot")
map1 <- tm_shape(HCSA_2020) +
  tm_fill("gi_star") + 
  tm_borders(alpha = 0.5) +
  tm_view(set.zoom.limits = c(6,8)) +
  tm_layout(main.title = "Gi* of Drug Use Cases in 2020",
            main.title.size = 0.8)

map2 <- tm_shape(HCSA_2020) +
  tm_fill("p_sim",
          breaks = c(0, 0.001, 0.01, 0.05, 1),
              labels = c("0.001", "0.01", "0.05", "Not sig")) + 
  tm_borders(alpha = 0.5) +
  tm_layout(main.title = "p-value of Gi*",
            main.title.size = 0.8)

tmap_arrange(map1, map2, ncol = 2)
```

Visualising the significant(p_sim \< 0.05) HCSA map.

```{r,fig.width=12,fig.height=10}
#| code-fold: true
HCSA_sig_2020 <- HCSA_2020  %>%
  filter(p_sim < 0.05)

map1 <- tm_shape(HCSA_2020) +
  tm_polygons() +
  tm_borders(alpha = 0.5) +
tm_shape(HCSA_sig_2020) +
  tm_fill("cluster") + 
  tm_borders(alpha = 0.4)

map2 <- tm_shape(HCSA_2020) +
  tm_polygons("no_cases",
          palette = "Blues",
          style="quantile", n=10)

tmap_arrange(map1, map2,ncol=2)
```

## 2021

Below code chunk will compute spatial weight matrix.

```{r}
#| code-fold: true
wm_idw_2021 <- drug_use_cases %>%
  filter(fiscal_year == 2021) %>%
  mutate(nb = include_self(st_contiguity(geometry)),
         geometry_centroid = st_centroid(geometry), 
         wts = st_inverse_distance(nb, 
                              geometry_centroid, 
                              scale = 1,
                              alpha = 1),
         .before = 1)

```

To compute the local G\* and using **set.seed()** to ensure the computation is reproducible.

```{r}
#| code-fold: true
set.seed(1234)
HCSA_2021 <- wm_idw_2021 %>% 
  mutate(local_Gi = local_gstar_perm(
    no_cases, nb, wts, nsim = 999),
         .before = 1) %>%
  unnest(local_Gi)

```

Visualising Gi\* and p_sim value using tmap at province level.

```{r,fig.width=12,fig.height=10}
#| code-fold: true
tmap_mode("plot")
map1 <- tm_shape(HCSA_2021) +
  tm_fill("gi_star") + 
  tm_borders(alpha = 0.5) +
  tm_view(set.zoom.limits = c(6,8)) +
  tm_layout(main.title = "Gi* of Drug Use Cases in 2021",
            main.title.size = 0.8)

map2 <- tm_shape(HCSA_2021) +
  tm_fill("p_sim",
          breaks = c(0, 0.001, 0.01, 0.05, 1),
              labels = c("0.001", "0.01", "0.05", "Not sig")) + 
  tm_borders(alpha = 0.5) +
  tm_layout(main.title = "p-value of Gi*",
            main.title.size = 0.8)

tmap_arrange(map1, map2, ncol = 2)
```

Visualising the significant(p_sim \< 0.05) HCSA map.

```{r,fig.width=12,fig.height=10}
#| code-fold: true
HCSA_sig_2021 <- HCSA_2021  %>%
  filter(p_sim < 0.05)

map1 <- tm_shape(HCSA_2021) +
  tm_polygons() +
  tm_borders(alpha = 0.5) +
tm_shape(HCSA_sig_2021) +
  tm_fill("cluster") + 
  tm_borders(alpha = 0.4)

map2 <- tm_shape(HCSA_2021) +
  tm_polygons("no_cases",
          palette = "Blues",
          style="quantile", n=10)

tmap_arrange(map1, map2,ncol=2)
```

## 2022

Below code chunk will compute spatial weight matrix.

```{r}
#| code-fold: true
wm_idw_2022 <- drug_use_cases %>%
  filter(fiscal_year == 2022) %>%
  mutate(nb = include_self(st_contiguity(geometry)),
         geometry_centroid = st_centroid(geometry), 
         wts = st_inverse_distance(nb, 
                              geometry_centroid, 
                              scale = 1,
                              alpha = 1),
         .before = 1)

```

To compute the local G\* and using **set.seed()** to ensure the computation is reproducible.

```{r}
#| code-fold: true
set.seed(1234)
HCSA_2022 <- wm_idw_2022 %>% 
  mutate(local_Gi = local_gstar_perm(
    no_cases, nb, wts, nsim = 999),
         .before = 1) %>%
  unnest(local_Gi)

```

Visualising Gi\* and p_sim value using tmap at province level.

```{r,fig.width=12,fig.height=10}
#| code-fold: true
tmap_mode("plot")
map1 <- tm_shape(HCSA_2022) +
  tm_fill("gi_star") + 
  tm_borders(alpha = 0.5) +
  tm_view(set.zoom.limits = c(6,8)) +
  tm_layout(main.title = "Gi* of Drug Use Cases in 2022",
            main.title.size = 0.8)

map2 <- tm_shape(HCSA_2022) +
  tm_fill("p_sim",
          breaks = c(0, 0.001, 0.01, 0.05, 1),
              labels = c("0.001", "0.01", "0.05", "Not sig")) + 
  tm_borders(alpha = 0.5) +
  tm_layout(main.title = "p-value of Gi*",
            main.title.size = 0.8)

tmap_arrange(map1, map2, ncol = 2)
```

Visualising the significant(p_sim \< 0.05) HCSA map.

```{r,fig.width=12,fig.height=10}
#| code-fold: true
HCSA_sig_2022 <- HCSA_2022  %>%
  filter(p_sim < 0.05)

map1 <- tm_shape(HCSA_2022) +
  tm_polygons() +
  tm_borders(alpha = 0.5) +
tm_shape(HCSA_sig_2022) +
  tm_fill("cluster") + 
  tm_borders(alpha = 0.4)

map2 <- tm_shape(HCSA_2022) +
  tm_polygons("no_cases",
          palette = "Blues",
          style="quantile", n=10)

tmap_arrange(map1, map2,ncol=2)
```
:::

::: callout-tip
## HCSA Insight

-   In 2017, there were two cold spot areas—one located above Bangkok and another surrounding the city. Notably, the cold spot area above Bangkok coincided with the Low-Low cluster identified in the LISA map.

-   By 2018, the cold spot above Bangkok had disappeared, while the area around Bangkok persisted. However, one province transitioned from a cold spot to a hot spot during this period.

-   In 2019, only one province remained as a cold spot around Bangkok, down from three provinces in 2018, while a new cold spot emerged in a province to the north. Additionally, the number of hot spots surrounding Bangkok increased.

-   In 2020, a new cold spot area appeared slightly above Bangkok, leaving only one province as a hot spot in the region.

-   By 2021, the hot spots had vanished, and a large cold spot area emerged to the left of Bangkok.

-   In 2022, the cold spot areas were reduced to two provinces, while a new hot spot emerged in the northern region.
:::

# 6. Emerging Hot Spot Analysis (EHSA)

In this section, I will explore how to perform **Emerging Hot Spot Analysis (EHSA)** on the current dataset.

EHSA is an exploratory spatial data analysis (ESDA) technique that integrates traditional hot spot analysis, using the Getis-Ord Gi\* statistic, with the time-series **Mann-Kendall test** for detecting monotonic trends.

By applying EHSA, I can assess how hot and cold spots evolve over time. I will begin by conducting the **Mann-Kendall test** to identify trends from 2017 to 2022, followed by the EHSA to analyze these spatial-temporal patterns.

First, I need to create a space-time cube to move forward with the analysis. The code snippet below will accomplish this task.

```{r}
spt <- as_spacetime(drug_use_cases, "province_en", "fiscal_year")
is_spacetime_cube(spt)
```

## 6.1 Mann-Kendall Test

The Mann-Kendall test for trend is a statistical method used to evaluate whether a dataset exhibits a significant upward or downward trend over time. This non-parametric test is versatile, as it does not assume the data follows a normal distribution, making it applicable to a wide range of data types. However, it is important that the data is free of **serial correlation**(AKA autocorrelation) for the test to be valid. If the data does follow a normal distribution, simple linear regression can be used as an alternative to assess trends.

The Hypothesis:

-   **Null hypothesis**: There is no monotonic trend in the series.

-   **Alternate hypothesis**: A trend exists. This trend can be positive, negative, or non-null.

Based on the HCSA section plot, I observed that from 2017 to 2020, the primary hot and cold spots were concentrated around Bangkok. However, in 2021 and 2022, a major hotspot emerged in the central-west region. As a result, I will conduct the Mann-Kendall test to examine the trends in the five provinces surrounding Bangkok: **Chachoengsao (1), Pathum Thani (2), Nonthaburi (3), Samut Sakhon (4),** and **Samut Prakan (5).**

![](website_img/bangkok_surrounding.jpg){fig-align="center" width="450"}

To compute spatial weight matrix of all years.

```{r}
wm_idw <- spt %>%
  activate("geometry") %>%
  mutate(nb = include_self(st_contiguity(geometry)),
         geometry_centroid = st_centroid(geometry), 
         wt = st_inverse_distance(nb, 
                              geometry_centroid, 
                              scale = 1,
                              alpha = 1),
         .before = 1) %>%
  set_nbs("nb") %>%
  set_wts("wt")
```

```{r}
head(wm_idw)
```

```{r}
class(wm_idw$nb)
```

Notices that the class of the `nb` field has changed to a list instead of a neighbors list due to the `set_nbs` function in the spacetime. The code snippet below will convert this field back into a neighbors list.

```{r}
class(wm_idw$nb) <- c("nb", "list")
class(wm_idw$nb)
```

To compute the local G\* and using **set.seed()** to ensure it is reproducible.

```{r}
set.seed(1234)
local_g_star_years <- wm_idw %>%
  group_by(fiscal_year) %>%
  mutate(local_Gi = local_gstar_perm(
    no_cases, nb, wt,nsim = 999),
    .before = 1) %>%
  unnest(local_Gi)
```

Filter the 5 province data.

```{r}
cha_gs <- local_g_star_years%>%
  filter(province_en == "Chachoengsao") |>
  select(province_en, fiscal_year, gi_star)

pt_gs <- local_g_star_years%>%
  filter(province_en == "Pathum Thani") |>
  select(province_en, fiscal_year, gi_star)

non_gs <- local_g_star_years%>%
  filter(province_en == "Nonthaburi") |>
  select(province_en, fiscal_year, gi_star)

ss_gs <- local_g_star_years%>%
  filter(province_en == "Samut Sakhon") |>
  select(province_en, fiscal_year, gi_star)

sp_gs <- local_g_star_years%>%
  filter(province_en == "Samut Prakan") |>
  select(province_en, fiscal_year, gi_star)

```

Lets visualize the trend of the G\* value of the 5 province surrounding Bangkok

```{r,fig.width=12,fig.height=10}
p_mkt <- ggplot() +
  geom_line(data = cha_gs, mapping = aes(x = fiscal_year, y = gi_star, color = "Chachoengsao")) +
  geom_line(data = pt_gs, mapping = aes(x = fiscal_year, y = gi_star, color = "Pathum Thani")) + 
  geom_line(data = non_gs, mapping = aes(x = fiscal_year, y = gi_star, color = "Nonthaburi")) + 
  geom_line(data = ss_gs, mapping = aes(x = fiscal_year, y = gi_star, color = "Samut Sakhon")) + 
  geom_line(data = sp_gs, mapping = aes(x = fiscal_year, y = gi_star, color = "Samut Prakan")) + 
  labs(x = "Year", y = "Gi* Value", 
       title = "Gi* value of the five province surrounding Bangkok",
       color = "Province")

plotly::ggplotly(p_mkt)
```

::: callout-tip
## Insight

-   We can observed that the Gi\* value of the five province are having a negative trend(from hot spot to cold spot) suggests that there is a tendency for the drug use cases around Bangkok decrease over time.
:::

## 6.2 Plotting EHSA

We can perform EHSA analysis by using `emerging_hotspot_analysis()` of **sfdep** package. It will takes a spacetime object named `spt` which I created at the start of this section. `.var` is the numeric vector in the spactime cube. Arguments `k` is to define the number of time lags to include in the neighborhood for calculating the local Gi\*. `nsim` is the number of simulations to run in calculating the simulated p-value for the local Gi\*.

```{r}
set.seed(1234)
EHSA <- emerging_hotspot_analysis(
  x = spt, 
  .var = "no_cases", 
  k = 1, 
  nsim = 999
)
```

### 6.2.1 Visualizing the EHSA

Before, we plot the EHSA map, lets plot a bar graph to see the distribution of the EHSA using **ggplot2**.

```{r}
ggplot(data = EHSA,
       aes(y = classification,fill = classification)) +
  geom_bar(show.legend = FALSE)
```

Before, we can plot the EHSA map, we need to perform left join with the Thailand sf object, as there is no geometry field in the EHSA .

```{r}
head(EHSA)
```

The following code chunk uses the `left_join()` function from the **dplyr** package. Since the two variables do not have a common field name, we specify the corresponding fields manually for the join.

```{r}
thailand_ehsa <- left_join(thailand_sf, EHSA,  by = join_by(province_en == location))
```

```{r}
head(thailand_ehsa)
```

Before plotting the map, we should typically only display provinces that are statistically significant (p-value \< 0.05). However, since it appears that all the provinces have p-values greater than 0.05, I will proceed with plotting the entire EHSA data with filtering of p-value \< 0.1 instead.

```{r}
thailand_ehsa_sig_0.05 <- thailand_ehsa  %>%
  filter(p_value < 0.05)
count(thailand_ehsa_sig_0.05)
```

```{r}
thailand_ehsa_sig_0.1 <- thailand_ehsa  %>%
  filter(p_value < 0.1)
count(thailand_ehsa_sig_0.1)
```

Now lets, plot the EHSA map using `tmap` functions.

```{r,fig.width=12,fig.height=10}
tmap_mode("plot")  
tm_shape(thailand_ehsa)+
  tm_polygons()+
  tm_borders(col = "black", alpha = 0.6)+
tm_shape(thailand_ehsa_sig_0.1)+
  tm_fill("classification", 
          palette = "Set1",
          title = "classification",
          midpoint = 0) +
  tm_borders(col = "black", alpha = 0.6)+
  tm_layout(main.title = "EHSA of Thailand Drug Use Cases",
            main.title.position = "center",
            main.title.size = 1.7,
            main.title.fontface = "bold",
            legend.title.size = 1.8,
            legend.text.size = 1.3,
            frame = TRUE) +
  tm_borders(alpha = 0.5) +
  tm_compass(type="8star", text.size = 1.5, size = 3, position=c("RIGHT", "TOP")) +
  tm_scale_bar(position=c("LEFT", "BOTTOM"), text.size=1.2)
```

::: callout-tip
## EHSA Insights

-   Notice that, even when I raise the p-value threshold to 0.1, only five provinces are identified.

-   I believe the potential reason for this may be that the distribution of drug use cases does not exhibit strong spatial clustering. This means there are no distinct areas where cases are significantly higher or lower than expected, which could be why the EHSA results show high p-values.
:::

# 7. Conclusions & Thoughts

The analysis of spatial autocorrelation and clustering for drug use cases across different years has provided valuable insights into the spatial patterns of drug offenses.

For **Global Moran’s I**, from 2017 to 2019, there was an increasing I value and decreasing p-value trend, though p-values remained above 0.05, indicating insufficient evidence to reject the null hypothesis of randomness. In 2020, the trend reversed, suggesting a more random distribution, likely due to the impact of COVID-19. However, in 2021 and 2022, we found enough evidence to infer weak spatial clustering.

Similarly, **Global Geary’s C** reflected these trends, with 2021 showing some discrepancy, where clustering was suggested by the actual p-value, but the simulated p-value indicated weaker evidence. By 2022, there was clear spatial autocorrelation, suggesting clustering.

The **LISA** analysis provided clearer visual evidence of clustering, effectively highlighting areas of high and low-value clusters. This method offered a more intuitive way to interpret spatial patterns compared to previous Local Moran’s I test maps. The use of the median, rather than the mean, in the LISA map provided a more robust representation of the data, revealing slight differences in the clustering patterns.

The **HCSA** insights demonstrated dynamic shifts in hot and cold spot areas over the years. While cold spots near Bangkok were prominent in 2017, they diminished over time, only to reappear or transition into new locations. Hot spots also fluctuated, disappearing in 2021 before reemerging in 2022 in the northern region.

Finally, the **EHSA** results indicated that the distribution of drug use cases may not exhibit strong spatial clustering, as evidenced by the high p-values. Even with a relaxed p-value threshold of 0.1, only a few provinces showed significant clustering, suggesting a more random or dispersed distribution of drug use cases across the region.

Overall, the results from Global Moran’s I, Geary’s C, LISA, HCSA and EHSA tests provide a nuanced picture of the spatial distribution of drug use cases in Thailand. While spatial clustering is evident in some years, overall, the data suggests a generally dispersed pattern, with weaker clustering in more recent years(2021 and 2022).

Unlike the first take-home exercise, this one went much more smoothly as I became more familiar with R. The in-class exercise 6 provided was particularly helpful in guiding me through the process, and by reviewing exercises from seniors in previous semesters provided valuable insight into what was expected for this exercise. Both resources played a key role in helping me complete the assignment efficiently.
