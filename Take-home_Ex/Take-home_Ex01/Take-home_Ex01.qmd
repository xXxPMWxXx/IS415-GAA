---
title: "Take-home Exercise 1: Geospatial Analytics for Social Good: Application of Spatial and Spatio-temporal Point Patterns Analysis to discover the geographical distribution of Armed Conflict in Myanmar"
author: "Pan Mingwei"
date: "September 5, 2024"
date-modified: "last-modified"
execute: 
  eval: true
  echo: true
  warning: false
  freeze: true
  cache: true
format: 
  html: 
    code-fold: false
    code-summary: "Click to expand/collapse code"
---

# 1. Overview

Millions of people have their lives shattered by armed conflict – wars – every year.

Armed conflict has been on the rise since about 2012, after a decline in the 1990s and early 2000s. First came conflicts in Libya, Syria and Yemen, triggered by the 2011 Arab uprisings. Libya’s instability spilled south, helping set off a protracted crisis in the Sahel region. A fresh wave of major combat followed: the 2020 Azerbaijani-Armenian war over the Nagorno-Karabakh enclave, horrific fighting in Ethiopia’s northern Tigray region that began weeks later, the conflict prompted by the Myanmar army’s 2021 power grab and Russia’s 2022 assault on Ukraine. Add to those 2023’s devastation in Sudan and Gaza. Around the globe, more people are dying in fighting, being forced from their homes or in need of life-saving aid than in decades.

## 1.1 Objective

Geospatial analytics hold tremendous potential to address complex problems facing society. In this study, I will apply spatial point patterns analysis methods to discover the spatial and spatio-temporal distribution of armed conflict in Myanmar.

## 1.2 Data

### 1.2.1 Armed Conflict Data

For the purpose of this assignment, armed conflict data of Myanmar between 2021-2024 from [Armed Conflict Location & Event Data (ACLED)](https://acleddata.com/), an independent, impartial, international non-profit organization collecting data on violent conflict and protest in all countries and territories in the world, should be used.

In terms of event types, I will focus on at least four main event types, namely: Battles, Explosion/Remote violence, Strategic developments, and Violence against civilians.

In terms of study period, I will focus on quarterly armed conflict events from January 2021 until June 2024.

### 1.2.2 GIS Data

I will be using [**Myanmar State and Region Boundaries with Sub-regions MIMU v9.4**](http://geonode.themimu.info/layers/geonode%3Ammr_polbnda2_adm1_250k_mimu_1) because it provides more detailed geospatial data, including sub-regions.

## 1.3 Importing Packages

The following R packages are used for this assignment:

-   **sf**, for importing, managing and processing geospatial data.

-   **tidyverse**, for importing, wrangling and visualising data.

-   **tmap**, to create thematic maps.

-   **spatstat**, for point pattern analysis.

-   **raster**,to reads, writes, manipulates, analyses and model of gridded spatial data (i.e. raster).

-   **sparr**, provides functions for kernel density estimation.

-   [**magick**](https://cran.r-project.org/web/packages/magick/vignettes/intro.html), modern and simple toolkit for image processing in R.

```{r}
pacman::p_load(sf,tidyverse,tmap,spatstat,sparr,raster,magick)
```

# 2. Data Wrangling

## 2.1 Aspatial Data

### 2.1.1 Importing Data

```{r}
acled_sf <- read_csv("data/aspatial/2021-01-01-2024-06-30-Myanmar.csv")
```

### 2.1.2 CRS Adjustment

```{r}
st_crs(acled_sf)
```

As the current **acled_sf** do not have CRS, which means there is no geometry column in the sf object. Therefore, before we change the CRS, we need to convert the **longitude** and **latitude** columns into a **spatial format**. Since Myanmar is UTM zone 47(EPSG:32647), lets create the geometry column and transform the CRS to `UTM Zone 47N`.

```{r}
acled_sf <- acled_sf %>%
  st_as_sf(coords = c("longitude", "latitude"), crs=4326) %>%
  st_transform(crs = 32647)
```

```{r}
st_crs(acled_sf)
```

We can see that now the CRS is `UTM Zone 47` now.

### 2.1.3 Check and Clean Aspatial Data

```{r}
head(acled_sf, n =1)
```

By checking the data, we can see that the data type for **event_date** was in Character instead of Date. And there is a timestamp field, in order to figure out what is this field for, we need to convert it to human readable as well.

Lets convert the data type for **event_date** to Date and **timestamp** to normal date time format, so we handle the field easier at later stage.

```{r}
acled_sf <- acled_sf %>%
  mutate(event_date = dmy(event_date)) %>%
  mutate(timestamp = as.POSIXct(timestamp, origin = "1970-01-01", tz = "Asia/Yangon"))
```

By looking at the data, it seems that the **timestamp** field was the date time when the data was recorded. Therefore, this field would not be useful for us.

### 2.1.4 Data Transformation

Since we will be focus on quarterly, lets extract **year** and **quarter** from **event_date** field.

```{r}
acled_sf <- acled_sf %>%
  mutate(year = year(event_date),
         quarter = quarter(event_date))
```

```{r}
summary(acled_sf)
```

#### 2.1.4.1 Handling Categorical Data

Since there are fields in the dataset are categorical related fields and they are in character vectors. To make sure consistency of the data, we can use `as.factor` function to convert the variable to categorical variable. These fields are: **disorder_type**, **event_type**, **sub_event_type**, **actor1**, **actor2**, **admin1** , **source_scale** etc.

By doing so, it makes easier to group and summarize data by categories and will provide more consistent behavior.

```{r}
acled_sf <- acled_sf %>%
  mutate( event_type = as.factor(event_type),
          admin1 = as.factor(admin1)
         )
         
```

::: callout-note
As there are other categorical fields, but since not all the field will be used and useful(as some of the field have too many level), hence I only factor fields that will be useful for the next stage.
:::

To check the levels.

```{r}
levels(acled_sf$event_type)
```

## 2.2 Geospatial Data

### 2.2.1 Importing Data

```{r}
msrb_sub_reg <- st_read(dsn = "data/geospatial/mmr_polbnda2_adm1_250k_mimu_1", layer = "mmr_polbnda2_adm1_250k_mimu_1")
```

### 2.2.2 CRS Adjustments

Lets check what is the CRS for `msrb_sub_reg`.

```{r}
st_crs(msrb_sub_reg)
```

As from above, we can see that the original data is geographic coordinate system. We need to convert it to projected coordinate system. Since Myanmar is UTM zone 47(EPSG:32647), lets transform the CRS to `UTM Zone 47N`.

```{r}
msrb_sub_reg <- st_transform(msrb_sub_reg, crs = 32647)
st_crs(msrb_sub_reg)
```

### 2.2.3 Check and Clean Geospatial Data

To ensure that the geometries in the shapefile are valid and correct them if any invalid geometries found.

```{r}
# Check if the data are valid
st_is_valid(msrb_sub_reg)
# Fix invalid data
msrb_sub_reg <- st_make_valid(msrb_sub_reg)
```

### 2.2.4 Standardize Column Names

We can see that the column name are not descriptive.

```{r}
msrb_sub_reg
```

Rename the column name to more descriptive name and remove not useful column .

```{r}
msrb_sub_reg <- msrb_sub_reg %>%
  rename(state_name = ST,
         state_pcode = ST_PCODE,
         state_region = ST_RG) %>%
  dplyr::select(-ST_MMR)
```

```{r}
summary(msrb_sub_reg)
```

### 2.2.5 Myanmar Boundaries

```{r, fig.width=12, fig.height=12}
plot(st_geometry(msrb_sub_reg))
```

### 2.2.6 Myanmar Boundaries With State Name

```{r, fig.width=10, fig.height=12}
ggplot(data = msrb_sub_reg) +
  geom_sf(aes(fill = state_name), color = "black") + 
  geom_sf_label(aes(label = state_name), size = 4, color = "black",fill = "white", label.size = 0.5) + 
  scale_fill_hue(n = length(unique(msrb_sub_reg$state_name))) +
  theme(legend.position = "right") +
  ggtitle("Myanmar Administrative Boundaries")
```

# 3 Kernel Density Estimation

## 3.1 Remove island

As we can see from above, the Myanmar boundaries have many islands, which will affect us as when plot the points. Therefore, by removing smaller island,it will help us in visualization.

```{r,fig.width=12, fig.height=12}
# Merge adj polygons
merged_msrb <- st_union(msrb_sub_reg) %>%
  st_cast("POLYGON")
# Convert back to sf object
merged_msrb <- st_as_sf(merged_msrb)
# set threshold
min_area_threshold <- units::set_units(100, "km^2")

areas <- st_area(merged_msrb)

# Filter out polygons smaller than the threshold
filtered_msrb <- merged_msrb %>% 
  filter(areas > min_area_threshold)

plot(st_geometry(filtered_msrb), main = "Without Small Islands")
```

```{r}
#| eval: false
write_rds(filtered_msrb, "data/rds/filtered_msrb.rds")
```

## 3.2 Create owin Object

```{r,fig.width=12, fig.height=12}
msrb_owin <- as.owin(filtered_msrb)
plot(msrb_owin)
```

## 3.3 Determine Best Sigma And Kernel

To find out which sigma and kernel to use for KDE, we will try various type and see which give us the best visualization. We will use data that is battles event in 2021 Q1 as the sample data.

```{r}
battles_2021_Q1 <- acled_sf %>%
  filter(event_type == 'Battles' & year == 2021 & quarter == 1)

battles_2021_Q1_ppp <- as.ppp(st_coordinates(battles_2021_Q1), st_bbox(battles_2021_Q1))
any(duplicated(battles_2021_Q1_ppp))
```

Using *`jittering`*, to add a small perturbation to the duplicate points so that they do not occupy the exact same space.

```{r}
battles_2021_Q1_ppp <- rjitter(battles_2021_Q1_ppp, 
                             retry=TRUE, 
                             nsim=1, 
                             drop=TRUE)
any(duplicated(battles_2021_Q1_ppp))
```

```{r,fig.width=12, fig.height=12}
battles_2021_Q1_ppp = battles_2021_Q1_ppp[msrb_owin]
plot(battles_2021_Q1_ppp, pch = 20, cex = 1)
```

```{r,fig.width=12, fig.height=12,cache=TRUE}
battles_2021_Q1_ppp = battles_2021_Q1_ppp[msrb_owin]
```

### 3.3.1 Comparing Different Sigma

```{r,fig.width=12, fig.height=12,cache=TRUE}
par(mfrow = c(2, 2))
par(mar = c(3, 3, 2, 1))  # adjust the margin values

plot(density(battles_2021_Q1_ppp, sigma = bw.ppl, edge = TRUE, kernel = "gaussian"), main = "PPL")
plot(density(battles_2021_Q1_ppp, sigma = bw.CvL, edge = TRUE, kernel = "gaussian"), main = "CvL")
plot(density(battles_2021_Q1_ppp, sigma = bw.scott, edge = TRUE, kernel = "gaussian"), main = "Scott")
plot(density(battles_2021_Q1_ppp, sigma = bw.diggle, edge = TRUE, kernel = "gaussian"), main = "Diggle")
```

::: callout-note
As can be seen above, among the four types of sigma, `PPL` provides the best visualization. Both Scott and CvL methods result in too much spread, while Diggle makes it difficult to see the points in the bottom part of the plot.
:::

### 3.3.2 Comparing Different Kernel

Check the bandwidth for `bw.ppl`.

```{r}
bw <- bw.ppl(battles_2021_Q1_ppp)
bw
```

```{r}
# Rescale the measurement unit
battles_2021_Q1_ppp.km <- rescale(battles_2021_Q1_ppp, 55000, "km")
```

```{r,fig.width=12, fig.height=12,cache=TRUE}
par(mfrow = c(2, 2))
par(mar = c(3, 3, 2, 1))

plot(density(battles_2021_Q1_ppp.km, sigma = bw.ppl, edge = TRUE, kernel = "gaussian"), main = "Gaussian")
plot(density(battles_2021_Q1_ppp.km, sigma = bw.ppl, edge = TRUE, kernel = "epanechnikov"), main = "Epanechnikov")
plot(density(battles_2021_Q1_ppp.km, sigma = bw.ppl, edge = TRUE, kernel = "quartic"), main = "Quartic")
plot(density(battles_2021_Q1_ppp.km, sigma = bw.ppl, edge = TRUE, kernel = "disc"), main = "Disc")
```

::: callout-note
Among the four kernels, the `Gaussian` kernel provides the smoothest visualization. Therefore, we will use Gaussian kernel for our analysis.
:::

## 3.4 AY2021

As I am interested in understanding an overall picture of the conflict situation each year, including how different types of conflicts happen concurrently. Therefore, I will analysis it by year and event type. By doing this way it will give me the following pros and cons:

-   Pros:

    -   **Holistic View**: I can compare multiple event types within the same time frame, identifying relationships or patterns between them.

    -   **Comprehensive Spatial Understanding**: Provide a snapshot of all event types within a year, is there any interactions between event type. (e.g. Battles occur near Violence against civilians)

-   Cons:

    -   **Temporal Trends Less Visible**: This way does not provide insight into how a specific event type evolves over the years.

### 3.4.1 Q1

```{r,fig.width=12, fig.height=12}
#| code-fold: true
event_types <- c("Battles", "Explosions/Remote violence", "Strategic developments", "Violence against civilians")

par(mfrow = c(2, 2))
par(mar = c(3, 3, 2, 1))
# Create a plot for each event type
for (event in event_types) {
  # Filter data by event type
  filtered_data <- acled_sf %>%
    filter(event_type == event & year == 2021 & quarter == 1)
  
  # Convert to ppp format
  ppp_data <- as.ppp(st_coordinates(filtered_data), st_bbox(filtered_data))
  
  # Handle duplicated points
  ppp_data <- rjitter(ppp_data, retry = TRUE, nsim = 1, drop = TRUE)
  
  # Extract conflict Event located within Myanmar
  ppp_data <- ppp_data[msrb_owin]
  
  # Re-scale
  ppp_data.km <- rescale(ppp_data, 55000, "km")
  
  # Plot KDE
  plot(density(ppp_data.km, 
               sigma = bw.ppl, 
               edge = TRUE, 
               kernel = "gaussian"), 
       main = paste("2021 Q1 -", event))
}
```

### 3.4.2 Q2

```{r,fig.width=12, fig.height=12}
#| code-fold: true
par(mfrow = c(2, 2))
par(mar = c(3, 3, 2, 1))
# Create a plot for each event type
for (event in event_types) {
  # Filter data by event type
  filtered_data <- acled_sf %>%
    filter(event_type == event & year == 2021 & quarter == 2)
  
  # Convert to ppp format
  ppp_data <- as.ppp(st_coordinates(filtered_data), st_bbox(filtered_data))
  
  # Handle duplicated points
  ppp_data <- rjitter(ppp_data, retry = TRUE, nsim = 1, drop = TRUE)
  
  # Extract conflict Event located within Myanmar
  ppp_data <- ppp_data[msrb_owin]
  
  # Re-scale
  ppp_data.km <- rescale(ppp_data, 55000, "km")
  
  # Plot density
  plot(density(ppp_data.km, 
               sigma = bw.ppl, 
               edge = TRUE, 
               kernel = "gaussian"), 
       main = paste("2021 Q2 -", event))
}
```

### 3.4.3 Q3

```{r,fig.width=12, fig.height=12}
#| code-fold: true
par(mfrow = c(2, 2))
par(mar = c(3, 3, 2, 1))
# Create a plot for each event type
for (event in event_types) {
  # Filter data by event type
  filtered_data <- acled_sf %>%
    filter(event_type == event & year == 2021 & quarter == 3)
  
  # Convert to ppp format
  ppp_data <- as.ppp(st_coordinates(filtered_data), st_bbox(filtered_data))
  
  # Handle duplicated points
  ppp_data <- rjitter(ppp_data, retry = TRUE, nsim = 1, drop = TRUE)
  
  # Extract conflict Event located within Myanmar
  ppp_data <- ppp_data[msrb_owin]
  
  # Re-scale
  ppp_data.km <- rescale(ppp_data, 55000, "km")
  
  # Plot density
  plot(density(ppp_data.km, 
               sigma = bw.ppl, 
               edge = TRUE, 
               kernel = "gaussian"), 
       main = paste("2021 Q3 -", event))
}
```

### 3.4.4 Q4

```{r,fig.width=12, fig.height=12}
#| code-fold: true
par(mfrow = c(2, 2))
par(mar = c(3, 3, 2, 1))
# Create a plot for each event type
for (event in event_types) {
  # Filter data by event type
  filtered_data <- acled_sf %>%
    filter(event_type == event & year == 2021 & quarter == 4)
  
  # Convert to ppp format
  ppp_data <- as.ppp(st_coordinates(filtered_data), st_bbox(filtered_data))
  
  # Handle duplicated points
  ppp_data <- rjitter(ppp_data, retry = TRUE, nsim = 1, drop = TRUE)
  
  # Extract conflict Event located within Myanmar
  ppp_data <- ppp_data[msrb_owin]
  
  # Re-scale
  ppp_data.km <- rescale(ppp_data, 55000, "km")
  
  # Plot density
  plot(density(ppp_data.km, 
               sigma = bw.ppl, 
               edge = TRUE, 
               kernel = "gaussian"), 
       main = paste("2021 Q4 -", event))
}
```

::: callout-tip
## 2021 Insight

-   In Q1 and Q2 of 2021, we can observe that **Battles** and **Explosions/Remote Violence** tend to occur in similar locations(the boundary between Kachin state and Shan state; Rakhine State and the boundary between Kayin State, Mon State and Yangon Division), suggesting a closer relationship between these two event type.

-   On the other hand, **Strategic Developments** and **Violence Against Civilians** appear to be spatially correlated with each other, mostly at the boundary between Magway Division and Mandalay Division , but less so with **Battles** and **Explosions/Remote Violence.**

-   By Q3 and Q4, as the frequency of conflicts increase, the spatial distribution of all four event type begins to converge mostly at the boundary between Magway Division and Mandalay Division. This suggests that these events are increasingly co-occurring in the similar geographic areas.
:::

## 3.5 AY2022

### 3.5.1 Q1

```{r,fig.width=12, fig.height=12}
#| code-fold: true
par(mfrow = c(2, 2))
par(mar = c(3, 3, 2, 1))
# Create a plot for each event type
for (event in event_types) {
  # Filter data by event type
  filtered_data <- acled_sf %>%
    filter(event_type == event & year == 2022 & quarter == 1)
  
  # Convert to ppp format
  ppp_data <- as.ppp(st_coordinates(filtered_data), st_bbox(filtered_data))
  
  # Handle duplicated points
  ppp_data <- rjitter(ppp_data, retry = TRUE, nsim = 1, drop = TRUE)
  
  # Extract conflict Event located within Myanmar
  ppp_data <- ppp_data[msrb_owin]
  
  # Re-scale
  ppp_data.km <- rescale(ppp_data, 55000, "km")
  
  # Plot density
  plot(density(ppp_data.km, 
               sigma = bw.ppl, 
               edge = TRUE, 
               kernel = "gaussian"), 
       main = paste("2022 Q1 -", event))
}
```

### 3.5.2 Q2

```{r,fig.width=12, fig.height=12}
#| code-fold: true
par(mfrow = c(2, 2))
par(mar = c(3, 3, 2, 1))
# Create a plot for each event type
for (event in event_types) {
  # Filter data by event type
  filtered_data <- acled_sf %>%
    filter(event_type == event & year == 2022 & quarter == 2)
  
  # Convert to ppp format
  ppp_data <- as.ppp(st_coordinates(filtered_data), st_bbox(filtered_data))
  
  # Handle duplicated points
  ppp_data <- rjitter(ppp_data, retry = TRUE, nsim = 1, drop = TRUE)
  
  # Extract conflict Event located within Myanmar
  ppp_data <- ppp_data[msrb_owin]
  
  # Re-scale
  ppp_data.km <- rescale(ppp_data, 55000, "km")
  
  # Plot density
  plot(density(ppp_data.km, 
               sigma = bw.ppl, 
               edge = TRUE, 
               kernel = "gaussian"), 
       main = paste("2022 Q2 -", event))
}
```

### 3.5.3 Q3

```{r,collapse = TRUE,fig.width=12, fig.height=12}
par(mfrow = c(2, 2))
par(mar = c(3, 3, 2, 1))
# Create a plot for each event type
for (event in event_types) {
  # Filter data by event type
  filtered_data <- acled_sf %>%
    filter(event_type == event & year == 2022 & quarter == 3)
  
  # Convert to ppp format
  ppp_data <- as.ppp(st_coordinates(filtered_data), st_bbox(filtered_data))
  
  # Handle duplicated points
  ppp_data <- rjitter(ppp_data, retry = TRUE, nsim = 1, drop = TRUE)
  
  # Extract conflict Event located within Myanmar
  ppp_data <- ppp_data[msrb_owin]
  
  # Re-scale
  ppp_data.km <- rescale(ppp_data, 55000, "km")
  
  # Plot density
  plot(density(ppp_data.km, 
               sigma = bw.ppl, 
               edge = TRUE, 
               kernel = "gaussian"), 
       main = paste("2022 Q3 -", event))
}
```

### 3.5.4 Q4

```{r,fig.width=12, fig.height=12}
#| code-fold: true
par(mfrow = c(2, 2))
par(mar = c(3, 3, 2, 1))
# Create a plot for each event type
for (event in event_types) {
  # Filter data by event type
  filtered_data <- acled_sf %>%
    filter(event_type == event & year == 2022 & quarter == 4)
  
  # Convert to ppp format
  ppp_data <- as.ppp(st_coordinates(filtered_data), st_bbox(filtered_data))
  
  # Handle duplicated points
  ppp_data <- rjitter(ppp_data, retry = TRUE, nsim = 1, drop = TRUE)
  
  # Extract conflict Event located within Myanmar
  ppp_data <- ppp_data[msrb_owin]
  
  # Re-scale
  ppp_data.km <- rescale(ppp_data, 55000, "km")
  
  # Plot density
  plot(density(ppp_data.km, 
               sigma = bw.ppl, 
               edge = TRUE, 
               kernel = "gaussian"), 
       main = paste("2022 Q4 -", event))
}
```

::: callout-tip
## 2022 Insight

-   In 2022, conflict levels remained high across all four event types. Most conflicts continued to occur along the boundary between **Magway Division** and **Mandalay Division** (central region). Toward end of the year, there was a noticeable increase in conflicts in the southern region, particularly in Battles and Violence Against Civilians events.
:::

## 3.6 AY2023

### 3.6.1 Q1

```{r,fig.width=12, fig.height=12}
#| code-fold: true
par(mfrow = c(2, 2))
par(mar = c(3, 3, 2, 1))
# Create a plot for each event type
for (event in event_types) {
  # Filter data by event type
  filtered_data <- acled_sf %>%
    filter(event_type == event & year == 2023 & quarter == 1)
  
  # Convert to ppp format
  ppp_data <- as.ppp(st_coordinates(filtered_data), st_bbox(filtered_data))
  
  # Handle duplicated points
  ppp_data <- rjitter(ppp_data, retry = TRUE, nsim = 1, drop = TRUE)
  
  # Extract conflict Event located within Myanmar
  ppp_data <- ppp_data[msrb_owin]
  
  # Re-scale
  ppp_data.km <- rescale(ppp_data, 55000, "km")
  
  # Plot density
  plot(density(ppp_data.km, 
               sigma = bw.ppl, 
               edge = TRUE, 
               kernel = "gaussian"), 
       main = paste("2023 Q1 -", event))
}
```

### 3.6.2 Q2

```{r,fig.width=12, fig.height=12}
#| code-fold: true
par(mfrow = c(2, 2))
par(mar = c(3, 3, 2, 1))
# Create a plot for each event type
for (event in event_types) {
  # Filter data by event type
  filtered_data <- acled_sf %>%
    filter(event_type == event & year == 2023 & quarter == 2)
  
  # Convert to ppp format
  ppp_data <- as.ppp(st_coordinates(filtered_data), st_bbox(filtered_data))
  
  # Handle duplicated points
  ppp_data <- rjitter(ppp_data, retry = TRUE, nsim = 1, drop = TRUE)
  
  # Extract conflict Event located within Myanmar
  ppp_data <- ppp_data[msrb_owin]
  
  # Re-scale
  ppp_data.km <- rescale(ppp_data, 55000, "km")
  
  # Plot density
  plot(density(ppp_data.km, 
               sigma = bw.ppl, 
               edge = TRUE, 
               kernel = "gaussian"), 
       main = paste("2023 Q2 -", event))
}
```

### 3.6.3 Q3

```{r,fig.width=12, fig.height=12}
#| code-fold: true
par(mfrow = c(2, 2))
par(mar = c(3, 3, 2, 1))
# Create a plot for each event type
for (event in event_types) {
  # Filter data by event type
  filtered_data <- acled_sf %>%
    filter(event_type == event & year == 2023 & quarter == 3)
  
  # Convert to ppp format
  ppp_data <- as.ppp(st_coordinates(filtered_data), st_bbox(filtered_data))
  
  # Handle duplicated points
  ppp_data <- rjitter(ppp_data, retry = TRUE, nsim = 1, drop = TRUE)
  
  # Extract conflict Event located within Myanmar
  ppp_data <- ppp_data[msrb_owin]
  
  # Re-scale
  ppp_data.km <- rescale(ppp_data, 55000, "km")
  
  # Plot density
  plot(density(ppp_data.km, 
               sigma = bw.ppl, 
               edge = TRUE, 
               kernel = "gaussian"), 
       main = paste("2023 Q3 -", event))
}
```

### 3.6.4 Q4

```{r,fig.width=12, fig.height=12}
#| code-fold: true
par(mfrow = c(2, 2))
par(mar = c(3, 3, 2, 1))
# Create a plot for each event type
for (event in event_types) {
  # Filter data by event type
  filtered_data <- acled_sf %>%
    filter(event_type == event & year == 2023 & quarter == 4)
  
  # Convert to ppp format
  ppp_data <- as.ppp(st_coordinates(filtered_data), st_bbox(filtered_data))
  
  # Handle duplicated points
  ppp_data <- rjitter(ppp_data, retry = TRUE, nsim = 1, drop = TRUE)
  
  # Extract conflict Event located within Myanmar
  ppp_data <- ppp_data[msrb_owin]
  
  # Re-scale
  ppp_data.km <- rescale(ppp_data, 55000, "km")
  
  # Plot density
  plot(density(ppp_data.km, 
               sigma = bw.ppl, 
               edge = TRUE, 
               kernel = "gaussian"), 
       main = paste("2023 Q4 -", event))
}
```

::: callout-tip
## 2023 Insight

-   Overall in 2023, most of the conflict for the four type continued to occur along the boundary between **Magway Division** and **Mandalay Division** (Central Region).

-   However, we can see a decreasing trend in Strategic Developments and Violence Against Civilians (can see from the scale bar at the side)

-   Conversely, Battles and Explosions/Remote Violence increased, with these events gradually shifting toward the boundary between **Kachin State** and **Shan State** (North-Ease Region)by the end of the year.
:::

## 3.7 AY2024

### 3.7.1 Q1

```{r,fig.width=12, fig.height=12}
#| code-fold: true
par(mfrow = c(2, 2))
par(mar = c(3, 3, 2, 1))
# Create a plot for each event type
for (event in event_types) {
  # Filter data by event type
  filtered_data <- acled_sf %>%
    filter(event_type == event & year == 2024 & quarter == 1)
  
  # Convert to ppp format
  ppp_data <- as.ppp(st_coordinates(filtered_data), st_bbox(filtered_data))
  
  # Handle duplicated points
  ppp_data <- rjitter(ppp_data, retry = TRUE, nsim = 1, drop = TRUE)
  
  # Extract conflict Event located within Myanmar
  ppp_data <- ppp_data[msrb_owin]
  
  # Re-scale
  ppp_data.km <- rescale(ppp_data, 55000, "km")
  
  # Plot density
  plot(density(ppp_data.km, 
               sigma = bw.ppl, 
               edge = TRUE, 
               kernel = "gaussian"), 
       main = paste("2024 Q1 -", event))
}
```

### 3.7.2 Q2

```{r,fig.width=12, fig.height=12}
#| code-fold: true
par(mfrow = c(2, 2))
par(mar = c(3, 3, 2, 1))
# Create a plot for each event type
for (event in event_types) {
  # Filter data by event type
  filtered_data <- acled_sf %>%
    filter(event_type == event & year == 2024 & quarter == 2)
  
  # Convert to ppp format
  ppp_data <- as.ppp(st_coordinates(filtered_data), st_bbox(filtered_data))
  
  # Handle duplicated points
  ppp_data <- rjitter(ppp_data, retry = TRUE, nsim = 1, drop = TRUE)
  
  # Extract conflict Event located within Myanmar
  ppp_data <- ppp_data[msrb_owin]
  
  # Re-scale
  ppp_data.km <- rescale(ppp_data, 55000, "km")
  
  # Plot density
  plot(density(ppp_data.km, 
               sigma = bw.ppl, 
               edge = TRUE, 
               kernel = "gaussian"), 
       main = paste("2024 Q2 -", event))
}
```

::: callout-tip
## 2024 Insight

-   In the first half of 2024, conflict trends remained similar to those of 2023, with the **Central region** being the primary hotspot, followed by the **Southern region**. However, there was a significant increase in conflict in **Rakhine State** during this period.

-   In term of co-relation between event types, **Battles** and **Explosions/Remote Violence** remained strongly correlated, while **Strategic Developments** and **Violence Against Civilians** also showed a continued correlation.
:::

# 4. Second-Order Spatial Point Pattern Analysis

For 2nd-order spatial point pattern analysis, each function(G,F,K,L) has their specific purpose:

-   `G-function`: Measure the distribution of distance from random points to the nearest event points. Helps in understanding how clustered points are. E.g. 1 to 500 (**Commonly used**)

-   `F-function`: Measures the distance from event points to random points. Complements the G-function, offering another way to detect clustering.

-   `K-function`: Estimates the number of points within a given distance of each other, providing a more general measure of spatial interaction across multiple scales. E.g.1 to 10, 10 to 20 etc . (**Commonly used**)

-   `L-function`: A linear transformation of the K-function that adjusts for boundary effects, making it easier to interpret by creating a straight line under complete spatial randomness.

## 4.1 Choosing Function and Number of Simulations

I want to find out that whether the conflict of the different event type that happen quarterly is evenly distributed or clustered. Since to compute for each event quarterly will need a long time to compute. Therefore, I will use `G-function` for the analysis, as compare to the other three functions, G-function tend to be faster and I will choose 200 for the number of simulations(Note the number of simulation start from 0, so I will use 199 for nsim).

## 4.2 2021

### 4.2.1 Q1

```{r}
event_types <- c("Battles", "Explosions/Remote violence", "Strategic developments", "Violence against civilians")
```

```{r,fig.width=12,fig.height=10}
#| code-fold: true

par(mfrow = c(2, 2))
par(mar = c(3, 3, 2, 1))
# Create a plot for each event type
for (event in event_types) {
  # Filter data by event type
  G_conflict <- acled_sf %>%
    filter(event_type == event & year == 2021 & quarter == 1)
  
  # Convert to ppp format
  G_conflict_ppp <- as.ppp(st_coordinates(G_conflict), st_bbox(G_conflict))
  # Handle duplicated points
  G_conflict_ppp <- rjitter(G_conflict_ppp, retry = TRUE, nsim = 1, drop = TRUE)
  # Extract event located within Myanmar
  G_conflict_ppp = G_conflict_ppp[msrb_owin]
  # Re-scale
  G_conflict_ppp.km <- rescale(G_conflict_ppp, 1000, "km")
  # Generate simulations
  G_conflict.csr <- envelope(G_conflict_ppp.km, Gest, nsim = 199)
  plot(G_conflict.csr, main = paste(event))
}
```

### 4.2.2 Q2

```{r,fig.width=12,fig.height=10}
#| code-fold: true

par(mfrow = c(2, 2))
par(mar = c(3, 3, 2, 1))
# Create a plot for each event type
for (event in event_types) {
  # Filter data by event type
  G_conflict <- acled_sf %>%
    filter(event_type == event & year == 2021 & quarter == 2)
  
  # Convert to ppp format
  G_conflict_ppp <- as.ppp(st_coordinates(G_conflict), st_bbox(G_conflict))
  # Handle duplicated points
  G_conflict_ppp <- rjitter(G_conflict_ppp, retry = TRUE, nsim = 1, drop = TRUE)
  # Extract event located within Myanmar
  G_conflict_ppp = G_conflict_ppp[msrb_owin]
  # Re-scale
  G_conflict_ppp.km <- rescale(G_conflict_ppp, 1000, "km")
  # Generate simulations
  G_conflict.csr <- envelope(G_conflict_ppp.km, Gest, nsim = 199)
  plot(G_conflict.csr, main = paste(event))
}
```

### 4.2.3 Q3

```{r,fig.width=12,fig.height=10}
#| code-fold: true

par(mfrow = c(2, 2))
par(mar = c(3, 3, 2, 1))
# Create a plot for each event type
for (event in event_types) {
  # Filter data by event type
  G_conflict <- acled_sf %>%
    filter(event_type == event & year == 2021 & quarter == 3)
  
  # Convert to ppp format
  G_conflict_ppp <- as.ppp(st_coordinates(G_conflict), st_bbox(G_conflict))
  # Handle duplicated points
  G_conflict_ppp <- rjitter(G_conflict_ppp, retry = TRUE, nsim = 1, drop = TRUE)
  # Extract event located within Myanmar
  G_conflict_ppp = G_conflict_ppp[msrb_owin]
  # Re-scale
  G_conflict_ppp.km <- rescale(G_conflict_ppp, 1000, "km")
  # Generate simulations
  G_conflict.csr <- envelope(G_conflict_ppp.km, Gest, nsim = 199)
  plot(G_conflict.csr, main = paste(event))
}
```

### 4.2.4 Q4

```{r,fig.width=12,fig.height=10}
#| code-fold: true

par(mfrow = c(2, 2))
par(mar = c(3, 3, 2, 1))
# Create a plot for each event type
for (event in event_types) {
  # Filter data by event type
  G_conflict <- acled_sf %>%
    filter(event_type == event & year == 2021 & quarter == 4)
  
  # Convert to ppp format
  G_conflict_ppp <- as.ppp(st_coordinates(G_conflict), st_bbox(G_conflict))
  # Handle duplicated points
  G_conflict_ppp <- rjitter(G_conflict_ppp, retry = TRUE, nsim = 1, drop = TRUE)
  # Extract event located within Myanmar
  G_conflict_ppp = G_conflict_ppp[msrb_owin]
  # Re-scale
  G_conflict_ppp.km <- rescale(G_conflict_ppp, 1000, "km")
  # Generate simulations
  G_conflict.csr <- envelope(G_conflict_ppp.km, Gest, nsim = 199)
  plot(G_conflict.csr, main = paste(event))
}
```

## 4.3 2022

### 4.3.1 Q1

```{r,fig.width=12,fig.height=10}
#| code-fold: true
par(mfrow = c(2, 2))
par(mar = c(3, 3, 2, 1))
# Create a plot for each event type
for (event in event_types) {
  # Filter data by event type
  G_conflict <- acled_sf %>%
    filter(event_type == event & year == 2022 & quarter == 1)
  
  # Convert to ppp format
  G_conflict_ppp <- as.ppp(st_coordinates(G_conflict), st_bbox(G_conflict))
  # Handle duplicated points
  G_conflict_ppp <- rjitter(G_conflict_ppp, retry = TRUE, nsim = 1, drop = TRUE)
  # Extract event located within Myanmar
  G_conflict_ppp = G_conflict_ppp[msrb_owin]
  # Re-scale
  G_conflict_ppp.km <- rescale(G_conflict_ppp, 1000, "km")
  # Generate simulations
  G_conflict.csr <- envelope(G_conflict_ppp.km, Gest, nsim = 199)
  plot(G_conflict.csr, main = paste(event))
}
```

### 4.3.2 Q2

```{r,fig.width=12,fig.height=10}
#| code-fold: true
par(mfrow = c(2, 2))
par(mar = c(3, 3, 2, 1))
# Create a plot for each event type
for (event in event_types) {
  # Filter data by event type
  G_conflict <- acled_sf %>%
    filter(event_type == event & year == 2022 & quarter == 2)
  
  # Convert to ppp format
  G_conflict_ppp <- as.ppp(st_coordinates(G_conflict), st_bbox(G_conflict))
  # Handle duplicated points
  G_conflict_ppp <- rjitter(G_conflict_ppp, retry = TRUE, nsim = 1, drop = TRUE)
  # Extract event located within Myanmar
  G_conflict_ppp = G_conflict_ppp[msrb_owin]
  # Re-scale
  G_conflict_ppp.km <- rescale(G_conflict_ppp, 1000, "km")
  # Generate simulations
  G_conflict.csr <- envelope(G_conflict_ppp.km, Gest, nsim = 199)
  plot(G_conflict.csr, main = paste(event))
}

```

### 4.3.3 Q3

```{r,fig.width=12,fig.height=10}
#| code-fold: true
par(mfrow = c(2, 2))
par(mar = c(3, 3, 2, 1))
# Create a plot for each event type
for (event in event_types) {
  # Filter data by event type
  G_conflict <- acled_sf %>%
    filter(event_type == event & year == 2022 & quarter == 3)
  
  # Convert to ppp format
  G_conflict_ppp <- as.ppp(st_coordinates(G_conflict), st_bbox(G_conflict))
  # Handle duplicated points
  G_conflict_ppp <- rjitter(G_conflict_ppp, retry = TRUE, nsim = 1, drop = TRUE)
  # Extract event located within Myanmar
  G_conflict_ppp = G_conflict_ppp[msrb_owin]
  # Re-scale
  G_conflict_ppp.km <- rescale(G_conflict_ppp, 1000, "km")
  # Generate simulations
  G_conflict.csr <- envelope(G_conflict_ppp.km, Gest, nsim = 199)
  plot(G_conflict.csr, main = paste(event))
}

```

### 4.3.4 Q4

```{r,fig.width=12,fig.height=10}
#| code-fold: true
par(mfrow = c(2, 2))
par(mar = c(3, 3, 2, 1))
# Create a plot for each event type
for (event in event_types) {
  # Filter data by event type
  G_conflict <- acled_sf %>%
    filter(event_type == event & year == 2022 & quarter == 4)
  
  # Convert to ppp format
  G_conflict_ppp <- as.ppp(st_coordinates(G_conflict), st_bbox(G_conflict))
  # Handle duplicated points
  G_conflict_ppp <- rjitter(G_conflict_ppp, retry = TRUE, nsim = 1, drop = TRUE)
  # Extract event located within Myanmar
  G_conflict_ppp = G_conflict_ppp[msrb_owin]
  # Re-scale
  G_conflict_ppp.km <- rescale(G_conflict_ppp, 1000, "km")
  # Generate simulations
  G_conflict.csr <- envelope(G_conflict_ppp.km, Gest, nsim = 199)
  plot(G_conflict.csr, main = paste(event))
}

```

## 4.4 2023

### 4.4.1 Q1

```{r,fig.width=12,fig.height=10}
#| code-fold: true
par(mfrow = c(2, 2))
par(mar = c(3, 3, 2, 1))
# Create a plot for each event type
for (event in event_types) {
  # Filter data by event type
  G_conflict <- acled_sf %>%
    filter(event_type == event & year == 2023 & quarter == 1)
  
  # Convert to ppp format
  G_conflict_ppp <- as.ppp(st_coordinates(G_conflict), st_bbox(G_conflict))
  # Handle duplicated points
  G_conflict_ppp <- rjitter(G_conflict_ppp, retry = TRUE, nsim = 1, drop = TRUE)
  # Extract event located within Myanmar
  G_conflict_ppp = G_conflict_ppp[msrb_owin]
  # Re-scale
  G_conflict_ppp.km <- rescale(G_conflict_ppp, 1000, "km")
  # Generate simulations
  G_conflict.csr <- envelope(G_conflict_ppp.km, Gest, nsim = 199)
  plot(G_conflict.csr, main = paste(event))
}

```

### 4.4.2 Q2

```{r,fig.width=12,fig.height=10}
#| code-fold: true
par(mfrow = c(2, 2))
par(mar = c(3, 3, 2, 1))
# Create a plot for each event type
for (event in event_types) {
  # Filter data by event type
  G_conflict <- acled_sf %>%
    filter(event_type == event & year == 2023 & quarter == 2)
  
  # Convert to ppp format
  G_conflict_ppp <- as.ppp(st_coordinates(G_conflict), st_bbox(G_conflict))
  # Handle duplicated points
  G_conflict_ppp <- rjitter(G_conflict_ppp, retry = TRUE, nsim = 1, drop = TRUE)
  # Extract event located within Myanmar
  G_conflict_ppp = G_conflict_ppp[msrb_owin]
  # Re-scale
  G_conflict_ppp.km <- rescale(G_conflict_ppp, 1000, "km")
  # Generate simulations
  G_conflict.csr <- envelope(G_conflict_ppp.km, Gest, nsim = 199)
  plot(G_conflict.csr, main = paste(event))
}

```

### 4.4.3 Q3

```{r,fig.width=12,fig.height=10}
#| code-fold: true
par(mfrow = c(2, 2))
par(mar = c(3, 3, 2, 1))
# Create a plot for each event type
for (event in event_types) {
  # Filter data by event type
  G_conflict <- acled_sf %>%
    filter(event_type == event & year == 2023 & quarter == 3)
  
  # Convert to ppp format
  G_conflict_ppp <- as.ppp(st_coordinates(G_conflict), st_bbox(G_conflict))
  # Handle duplicated points
  G_conflict_ppp <- rjitter(G_conflict_ppp, retry = TRUE, nsim = 1, drop = TRUE)
  # Extract event located within Myanmar
  G_conflict_ppp = G_conflict_ppp[msrb_owin]
  # Re-scale
  G_conflict_ppp.km <- rescale(G_conflict_ppp, 1000, "km")
  # Generate simulations
  G_conflict.csr <- envelope(G_conflict_ppp.km, Gest, nsim = 199)
  plot(G_conflict.csr, main = paste(event))
}

```

### 4.4.4 Q4

```{r,fig.width=12,fig.height=10}
#| code-fold: true
par(mfrow = c(2, 2))
par(mar = c(3, 3, 2, 1))
# Create a plot for each event type
for (event in event_types) {
  # Filter data by event type
  G_conflict <- acled_sf %>%
    filter(event_type == event & year == 2023 & quarter == 4)
  
  # Convert to ppp format
  G_conflict_ppp <- as.ppp(st_coordinates(G_conflict), st_bbox(G_conflict))
  # Handle duplicated points
  G_conflict_ppp <- rjitter(G_conflict_ppp, retry = TRUE, nsim = 1, drop = TRUE)
  # Extract event located within Myanmar
  G_conflict_ppp = G_conflict_ppp[msrb_owin]
  # Re-scale
  G_conflict_ppp.km <- rescale(G_conflict_ppp, 1000, "km")
  # Generate simulations
  G_conflict.csr <- envelope(G_conflict_ppp.km, Gest, nsim = 199)
  plot(G_conflict.csr, main = paste(event))
}

```

## 4.5 2024

### 4.5.1 Q1

```{r,fig.width=12,fig.height=10}
#| code-fold: true
par(mfrow = c(2, 2))
par(mar = c(3, 3, 2, 1))
# Create a plot for each event type
for (event in event_types) {
  # Filter data by event type
  G_conflict <- acled_sf %>%
    filter(event_type == event & year == 2024 & quarter == 1)
  
  # Convert to ppp format
  G_conflict_ppp <- as.ppp(st_coordinates(G_conflict), st_bbox(G_conflict))
  # Handle duplicated points
  G_conflict_ppp <- rjitter(G_conflict_ppp, retry = TRUE, nsim = 1, drop = TRUE)
  # Extract event located within Myanmar
  G_conflict_ppp = G_conflict_ppp[msrb_owin]
  # Re-scale
  G_conflict_ppp.km <- rescale(G_conflict_ppp, 1000, "km")
  # Generate simulations
  G_conflict.csr <- envelope(G_conflict_ppp.km, Gest, nsim = 199)
  plot(G_conflict.csr, main = paste(event))
}
```

### 4.5.2 Q2

```{r,fig.width=12,fig.height=10}
#| code-fold: true
par(mfrow = c(2, 2))
par(mar = c(3, 3, 2, 1))
# Create a plot for each event type
for (event in event_types) {
  # Filter data by event type
  G_conflict <- acled_sf %>%
    filter(event_type == event & year == 2024 & quarter == 2)
  
  # Convert to ppp format
  G_conflict_ppp <- as.ppp(st_coordinates(G_conflict), st_bbox(G_conflict))
  # Handle duplicated points
  G_conflict_ppp <- rjitter(G_conflict_ppp, retry = TRUE, nsim = 1, drop = TRUE)
  # Extract event located within Myanmar
  G_conflict_ppp = G_conflict_ppp[msrb_owin]
  # Re-scale
  G_conflict_ppp.km <- rescale(G_conflict_ppp, 1000, "km")
  # Generate simulations
  G_conflict.csr <- envelope(G_conflict_ppp.km, Gest, nsim = 199)
  plot(G_conflict.csr, main = paste(event))
}

```

## 4.6 Insight

::: callout-tip
## 2nd Order Spatial Point Pattern Analysis Insight

-   From the quarterly plots, the observed line in most cases lies above the envelope, indicating clustering in the conflict locations. An exception is seen in **2021 Q1**, where the plot for **violence against civilians** shows the observed line entering the envelope toward the end.

-   Overall, this confirms that the spatial patterns for all four event types exhibit clustering over the years.
:::

# 5. Spatio-temporal KDE

## 5.1 Prepare the Data

To only select the necessary fields to save memory and create a year_quarter field ,make it as factors for later to plot the graph.

::: callout-note
year_quarter need to be in numeric in order to compute STDKE.

-   2021 Q1 =\> 2021.00

-   2021 Q2 =\> 2021.25

-   2021 Q3 =\> 2021.50

-   2021 Q4 =\> 2021.75
:::

```{r}
#| eval: false
acled_sf <- acled_sf %>%
  dplyr::select(event_date, event_type, year,quarter) %>%
  # mutate(year_quarter = as.factor(paste(year, quarter, sep = "-")))
  mutate(year_quarter = round(year + (quarter - 1) / 4, 2) )
```

```{r}
#| eval: false
battles_sf <- acled_sf %>%
    filter(event_type == "Battles")

explosions_sf <- acled_sf %>%
    filter(event_type == "Explosions/Remote violence")

strategic_sf <- acled_sf %>%
    filter(event_type == "Strategic developments") 

civilians_sf <- acled_sf %>%
    filter(event_type == "Violence against civilians") 
```

Save the Data into rds.

```{r}
#| eval: false
write_rds(acled_sf, "data/rds/acled_sf.rds")
write_rds(battles_sf, "data/rds/battles_sf.rds")
write_rds(explosions_sf, "data/rds/explosions_sf.rds")
write_rds(strategic_sf, "data/rds/strategic_sf.rds")
write_rds(civilians_sf, "data/rds/civilians_sf.rds")
```

```{r}
filtered_msrb <- read_rds("data/rds/filtered_msrb.rds")
battles_sf <- read_rds("data/rds/battles_sf.rds")
explosions_sf <- read_rds("data/rds/explosions_sf.rds")
strategic_sf <- read_rds("data/rds/strategic_sf.rds")
civilians_sf <- read_rds("data/rds/civilians_sf.rds")
```

## 5.2 Overview

Using `tmap` packages to plot over 2021 to 2024.

::: panel-tabset
## Battles

```{r,fig.width=12,fig.height=10}
tm_shape(filtered_msrb) +
  tm_polygons() +
  tm_shape(battles_sf) +
  tm_dots()
```

## Explosions/Remote violence

```{r,fig.width=12,fig.height=10}
tm_shape(filtered_msrb) +
  tm_polygons() +
  tm_shape(explosions_sf) +
  tm_dots()
```

## Strategic developments

```{r,fig.width=12,fig.height=10}
tm_shape(filtered_msrb) +
  tm_polygons() +
  tm_shape(strategic_sf) +
  tm_dots()
```

## Violence against civilians

```{r,fig.width=12,fig.height=10}
tm_shape(filtered_msrb) +
  tm_polygons() +
  tm_shape(civilians_sf) +
  tm_dots()
```
:::

## 5.3 Visualizing Distribution of Conflict by Quarter

::: panel-tabset
## Battles

```{r,fig.width=6,fig.height=10}
#| code-fold: true
tm_shape(filtered_msrb) +
  tm_polygons() +
  tm_shape(battles_sf) +
  tm_dots(size = 0.1) +
  tm_facets(by="year_quarter",
            free.coords = FALSE, # To avoid the zoom issue of the display map
            drop.units = TRUE,
            nrow = 4)
```

## Explosions/Remote violence

```{r,fig.width=6,fig.height=10}
#| code-fold: true
tm_shape(filtered_msrb) +
  tm_polygons() +
  tm_shape(explosions_sf) +
  tm_dots(size = 0.1) +
  tm_facets(by="year_quarter",
            free.coords = FALSE, # To avoid the zoom issue of the display map
            drop.units = TRUE,
            nrow = 4)
```

## Strategic developments

```{r,fig.width=6,fig.height=10}
#| code-fold: true
tm_shape(filtered_msrb) +
  tm_polygons() +
  tm_shape(strategic_sf) +
  tm_dots(size = 0.1) +
  tm_facets(by="year_quarter",
            free.coords = FALSE, # To avoid the zoom issue of the display map
            drop.units = TRUE,
            nrow = 4)
```

## Violence against civilians

```{r,fig.width=6,fig.height=10}
#| code-fold: true
tm_shape(filtered_msrb) +
  tm_polygons() +
  tm_shape(civilians_sf) +
  tm_dots(size = 0.1) +
  tm_facets(by="year_quarter",
            free.coords = FALSE, # To avoid the zoom issue of the display map
            drop.units = TRUE,
            nrow = 4)
```
:::

## 5.3 Computing STDKE by Quarter

### 5.3.1 Creating ppp object.

Remove unwanted fields. As ppp object only need mark field and geometry field from the data frame.

```{r}
battles_quarter <- battles_sf %>%
  dplyr::select(year_quarter)

explosions_quarter <- explosions_sf %>%
  dplyr::select(year_quarter)

strategic_quarter <- strategic_sf %>%
  dplyr::select(year_quarter)

civilians_quarter <- civilians_sf %>%
  dplyr::select(year_quarter)
```

```{r}
battles_quarter_ppp <- as.ppp(battles_quarter)
explosions_quarter_ppp <- as.ppp(explosions_quarter)
strategic_quarter_ppp <- as.ppp(strategic_quarter)
civilians_quarter_ppp <- as.ppp(civilians_quarter)
```

Check if there is duplicated point.

```{r}
any(duplicated(battles_quarter_ppp))
any(duplicated(explosions_quarter_ppp))
any(duplicated(strategic_quarter_ppp))
any(duplicated(civilians_quarter_ppp))
```

Handle duplicated points.

```{r}
battles_quarter_ppp <- rjitter(battles_quarter_ppp, retry = TRUE, nsim = 1, drop = TRUE)
explosions_quarter_ppp <- rjitter(explosions_quarter_ppp, retry = TRUE, nsim = 1, drop = TRUE)
strategic_quarter_ppp <- rjitter(strategic_quarter_ppp, retry = TRUE, nsim = 1, drop = TRUE)
civilians_quarter_ppp <- rjitter(civilians_quarter_ppp, retry = TRUE, nsim = 1, drop = TRUE)
```

```{r}
any(duplicated(battles_quarter_ppp))
any(duplicated(explosions_quarter_ppp))
any(duplicated(strategic_quarter_ppp))
any(duplicated(civilians_quarter_ppp))
```

### 5.3.2 Including Owin object

```{r}
msrb_owin <- as.owin(filtered_msrb)
```

```{r}
battles_quarter_owin <- battles_quarter_ppp[msrb_owin]
explosions_quarter_owin <- explosions_quarter_ppp[msrb_owin]
strategic_quarter_owin <- strategic_quarter_ppp[msrb_owin]
civilians_quarter_owin <- civilians_quarter_ppp[msrb_owin]
# summary(battles_quarter_owin)
```

### 5.3.3 Compute STKDE for Events

Compute STKDE for battles event.

```{r}
# Re-scale
battles_quarter_owin.km <- rescale(battles_quarter_owin, 1000, "km")
battles_st_kde <- spattemp.density(battles_quarter_owin.km)
summary(battles_st_kde)
```

Explosions/remote violence

```{r}
# Re-scale
explosions_quarter_owin.km <- rescale(explosions_quarter_owin, 1000, "km")
explosions_st_kde <- spattemp.density(explosions_quarter_owin.km)
summary(explosions_st_kde)
```

Strategic Developments

```{r}
# Re-scale
strategic_quarter_owin.km <- rescale(strategic_quarter_owin, 1000, "km")
strategic_st_kde <- spattemp.density(strategic_quarter_owin.km)
summary(strategic_st_kde)
```

Violence Against Civilians

```{r}
# Re-scale
civilians_quarter_owin.km <- rescale(civilians_quarter_owin, 1000, "km")
civilians_st_kde <- spattemp.density(civilians_quarter_owin.km)
summary(civilians_st_kde)
```

### 5.3.4 STDKE Plot

Create variables for later use. Mainly **times** for the time field for STKDE and **time_labels** for the naming of the plot.

```{r}
times <- seq(2021.00, 2024.25, by = 0.25)
time_labels <- sapply(times, function(t) {
  year <- floor(t)
  quarter <- ((t - year) * 4) + 1
  paste(year, " Q", quarter, sep = "")
})
```

::: panel-tabset
## Battles

```{r,fig.width=12,fig.height=10}
par(mfrow = c(2, 2))
for(i in seq_along(times)){
  plot(battles_st_kde, times[i] ,
       override.par=FALSE,
       fix.range=TRUE,
       main=paste("Battles STKDE in ",time_labels[i])
       )
}
```

## Explosions/Remote Violence

```{r,fig.width=12,fig.height=10}
par(mfrow = c(2, 2))
for(i in seq_along(times)){
  plot(explosions_st_kde, times[i] ,
       override.par=FALSE,
       fix.range=TRUE,
       main=paste("Explosions/Remote Violence STKDE in ",time_labels[i])
       )
}
```

## Strategic Developments

```{r,fig.width=12,fig.height=10}
par(mfrow = c(2, 2))
for(i in seq_along(times)){
  plot(strategic_st_kde, times[i] ,
       override.par=FALSE,
       fix.range=TRUE,
       main=paste("Strategic Developments STKDE in ",time_labels[i])
       )
}
```

## Violence Against Civilians

```{r,fig.width=12,fig.height=10}
par(mfrow = c(2, 2))
for(i in seq_along(times)){
  plot(civilians_st_kde, times[i] ,
       override.par=FALSE,
       fix.range=TRUE,
       main=paste("Violence Against Civilians STKDE in ",time_labels[i])
       )
}
```
:::

### 5.3.5 Animate the Plot

To better visualize the spatial-temporal KDE plot, I will use `magick` package in R to convert a sequence of PNG images into a dynamic GIF. Each PNG file represents spatial-temporal KDE plots for different quarters, and I am combining them into an animated GIF that visually depicts changes in data over time. The `magick` package allows me to handle and manipulate these images seamlessly, and I am setting parameters like the frame rate (fps) to control the speed of the animation.

::: panel-tabset
## Battles

```{r}
#| code-fold: true
#| eval: false
for(i in seq_along(times)){
   # Define the file path
  file_path <- paste0("data/images/", time_labels[i], "_Battles.png")
  
  # Open a PNG device
  png(file_path, width = 800, height = 600)
  plot(battles_st_kde, times[i] ,
       override.par=FALSE,
       fix.range=TRUE,
       main=paste("Battles STKDE in ",time_labels[i])
       )
  dev.off()
}
```

```{r}
image_files <- list.files("data/images/", pattern = "_Battles\\.png", full.names = TRUE)
image_files <- sort(image_files) 
# Read images into a list
images <- image_read(image_files)

# Create an animation
animation <- image_animate(images, fps = 1)

# Display the animation
print(animation)
```

## Explosions/Remote Violence

```{r}
#| code-fold: true
#| eval: false
for(i in seq_along(times)){
   # Define the file path
  file_path <- paste0("data/images/", time_labels[i], "_Explosions.png")
  
  # Open a PNG device
  png(file_path, width = 800, height = 600)
  plot(explosions_st_kde, times[i] ,
       override.par=FALSE,
       fix.range=TRUE,
       main=paste("Explosions/Remote Violence STKDE in ",time_labels[i])
       )
  dev.off()
}
```

```{r}
image_files <- list.files("data/images/", pattern = "_Explosions\\.png", full.names = TRUE)
image_files <- sort(image_files) 
# Read images into a list
images <- image_read(image_files)

# Create an animation
animation <- image_animate(images, fps = 1)

# Display the animation
print(animation)
```

## Strategic Developments

```{r}
#| code-fold: true
#| eval: false
for(i in seq_along(times)){
   # Define the file path
  file_path <- paste0("data/images/", time_labels[i], "_Strategic.png")
  
  # Open a PNG device
  png(file_path, width = 800, height = 600)
  plot(explosions_st_kde, times[i] ,
       override.par=FALSE,
       fix.range=TRUE,
       main=paste("Strategic Developments STKDE in ",time_labels[i])
       )
  dev.off()
}
```

```{r}
image_files <- list.files("data/images/", pattern = "_Strategic\\.png", full.names = TRUE)
image_files <- sort(image_files) 
# Read images into a list
images <- image_read(image_files)

# Create an animation
animation <- image_animate(images, fps = 1)

# Display the animation
print(animation)
```

## Violence Against Civilians

```{r}
#| code-fold: true
#| eval: false
for(i in seq_along(times)){
   # Define the file path
  file_path <- paste0("data/images/", time_labels[i], "_Civilians.png")
  
  # Open a PNG device
  png(file_path, width = 800, height = 600)
  plot(explosions_st_kde, times[i] ,
       override.par=FALSE,
       fix.range=TRUE,
       main=paste("Violence Against Civilians STKDE in ",time_labels[i])
       )
  dev.off()
}
```

```{r}
image_files <- list.files("data/images/", pattern = "_Civilians\\.png", full.names = TRUE)
image_files <- sort(image_files) 
# Read images into a list
images <- image_read(image_files)

# Create an animation
animation <- image_animate(images, fps = 1)

# Display the animation
print(animation)
```
:::

### 5.3.6 Insights

::: callout-tip
## STKDE Insights

-   In term of conflict density, we can see that for all four event types, conflicts are primarily occur at the central regions (boundary between Sagaing State, Magway State and Mandalay Sate ) and southern regions(Yangon State, Mon State and Kayin State)

-   As for conflict intensity over the years. We can see that the pattern are similar for the four event types. The intensity increasing start from 2021 Q1 and reach peak in 2022 Q4, and then shows a declining trend from 2023 through 2024 Q2.

-   In terms of the correlation between event types, **battles** and **explosions/remote violence** are more closely related, particularly in the southern regions, where the density patterns for both event types are quite similar. On the other hand, **strategic developments** and **violence against civilians** are more aligned with each other, as their patterns and densities show similar trends over the same period.
:::

```{r}
#| eval: false
current_ppp <- battles_quarter_ppp[battles_quarter$year_quarter == 2021.00 ]
current_ppp <- current_ppp[msrb_owin]
current_ppp.km <- rescale(current_ppp, 1000, "km")
density <- density(current_ppp,sigma=bw.ppl)
```

```{r,fig.width=12,fig.height=10}
#| eval: false
# Convert density to raster
current_raster <- raster(density)
  
projection(current_raster) <- CRS("+init=EPSG:3414")
tm_shape(current_raster) + 
  tm_raster("layer", palette = "viridis") +
  tm_layout(legend.position = c("right", "bottom"), frame = FALSE)
```

```{r}
#| eval: false
# Create an empty list to store rasters
raster_list <- list()

# Calculate density for each time slice and convert to raster
for (t in times) {
  # Filter data for the current time slice
  current_ppp <- battles_quarter_ppp[battles_quarter$year_quarter == t]
  
  # Calculate density
  density <- density(current_ppp,sigma=bw.diggle, edge=TRUE, kernel="gaussian")
  
  # Convert density to raster
  current_raster <- raster(density)
  
  projection(current_raster) <- CRS("+init=EPSG:3414")
  tm_shape(current_raster) + 
  tm_raster("layer", palette = "viridis") +
  tm_layout(legend.position = c("right", "bottom"), frame = FALSE)
  # Store raster in the list with time as the name
  #raster_list[[time_labels[which(times == t)]]] <- current_raster
}



```
