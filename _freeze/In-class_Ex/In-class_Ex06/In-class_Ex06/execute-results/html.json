{
  "hash": "1be1ff4b0e2195e4ce3cbb163d615628",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"In-class Exercise 06: Global/Local Measures of Spatial Autocorrelation\"\nauthor: \"Pan Mingwei\"\ndate: \"September 22, 2024\"\ndate-modified: \"last-modified\"\nexecute: \n  eval: true\n  echo: true\n  warning: false\n  freeze: true\n---\n\n\n::: callout-note\n## In Class Notes\n\n-   Instead of interested in whether the distribution are normally distributed, but rather focus more on whether the data set are randomly distributed.\n\n    -   If we can reject that the data set is not randomly distributed, then we can infer whether it is clustered or dispersed.\n\n-   How to identify outlier?\n\n    -   E.g. if the neighbours are all with high GDPPC, then most likely it will be the outlier. However, we need to perform statistical analysis to confirm it. =\\> using LMSA\n\n-   Need to be able to reject the null hypothesis(it is not randomly distributed), then we can infer whether there is spatial autocorrelation. (Use term such as weak/strong spatial autocorrelation)\n\n    -   Positive Spatial autocorrelation =\\> clustering and little or no outliers.\n\n    -   Negative Spatial autocorrelation =\\> means there will be more outliers.\n\n-   GMSA:\n\n    -   **Moran'I** =\\> Make use of mean(itself and it's neighbours) to calculate the I value. To check how differ in the study area as a whole.\n\n    -   **Geary C** =\\> compare itself and it's neighbours. To check the difference from immediate neighbours.\n\n        -   The lowest value will be 0, but the highest value can be inf.\n\n        -   Would not be smaller than 0.\n\n-   LMSA:\n\n    -   **Getis-Ord Gi/Gi\\*** =\\> must use distance matrix and all positive value.\n\n        -   Use to identify clusters.\n\n        -   G\\* =\\> consider itself.\n\n        -   G =\\> do not consider itself.\n\n        -   **Note**: not to identify outliers, but clusters.\n\n    -   **LISA** =\\> to identify clusters or outliers.\n\n        -   Clusters:\n\n            -   HH =\\> High value area ,surrounded by high value neighbours\n\n            -   LL =\\> Low value area, surrounded by low value neighbours.\n\n        -   Outliers:\n\n            -   HL =\\> High value area ,surrounded by low value neighbours\n\n            -   LH =\\> Low value area, surrounded by high value neighbours.\n\n-   Tips on choosing color for the plot.\n\n    -   If there are positive and negative value =\\> choose the diverging color scheme.\n\n    -   For nominal data =\\> try use distinct color.\n:::\n\n# 1. Getting Started\n\nTo load the R packages.\n\n-   **sf** is use for importing and handling geospatial data in R,\n\n-   **tidyverse** is mainly use for wrangling attribute data in R,\n\n-   **sfped,** builds on the great shoulders of spdep package for spatial dependence. sfdep creates an sf and tidyverse friendly interface\n\n-   **tmap** will be used to prepare cartographic quality chropleth map.\n\n\n::: {.cell}\n\n```{.r .cell-code}\npacman::p_load(sf, sfdep, tmap, tidyverse)\n```\n:::\n\n\n## 1.1 Import the data\n\n-   Hunan province administrative boundary layer at county level. This is a geospatial data set in ESRI shapefile format.\n\n-   Hunan_2012.csv: This csv file contains selected Hunan’s local development indicators in 2012.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nhunan_sf <- st_read(dsn = \"data/geospatial\", \n                 layer = \"Hunan\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nReading layer `Hunan' from data source \n  `/Users/mingwei/Desktop/SMU/Y3S1/IS415/xXxPMWxXx/IS415-GAA/In-class_Ex/In-class_Ex06/data/geospatial' \n  using driver `ESRI Shapefile'\nSimple feature collection with 88 features and 7 fields\nGeometry type: POLYGON\nDimension:     XY\nBounding box:  xmin: 108.7831 ymin: 24.6342 xmax: 114.2544 ymax: 30.12812\nGeodetic CRS:  WGS 84\n```\n\n\n:::\n:::\n\n\nUsing **`read_csv`** function from **tidyverse** package.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nhunan2012 <- read_csv(\"data/aspatial/Hunan_2012.csv\")\n```\n:::\n\n\nUsing `left_join()` of **dplyr** package to update the attribute table of hunan_sf with the attribute fields of hunan2012 dataframe.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nhunan_sf_GDPPC <- left_join(hunan_sf,hunan2012) %>%\n  dplyr::select(1:4, 7, 15)\n```\n:::\n\n\n# 2. Global Measures of Spatial Autocorrelation\n\n## 2.1 Deriving Queen's contiguity weight: sfdep methods\n\n\n::: {.cell}\n\n```{.r .cell-code}\nwm_q <- hunan_sf_GDPPC %>%\n  mutate(nb = st_contiguity(geometry),\n         wt = st_weights(nb,\n                         style = \"W\"),\n         .before = 1) # the new column will be add to the front.\n```\n:::\n\n\n## 2.2 Computing Global Moran'I\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmoranI <- global_moran(wm_q$GDPPC,\n                       wm_q$nb,\n                       wm_q$wt)\n\nglimpse(moranI)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nList of 2\n $ I: num 0.301\n $ K: num 7.64\n```\n\n\n:::\n:::\n\n\nk =\\> the average neighbour in the data.\n\n## 2.3 Performing Global Moran's I Test\n\n\n::: {.cell}\n\n```{.r .cell-code}\nglobal_moran_test(wm_q$GDPPC,\n                       wm_q$nb,\n                       wm_q$wt)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n\n\tMoran I test under randomisation\n\ndata:  x  \nweights: listw    \n\nMoran I statistic standard deviate = 4.7351, p-value = 1.095e-06\nalternative hypothesis: greater\nsample estimates:\nMoran I statistic       Expectation          Variance \n      0.300749970      -0.011494253       0.004348351 \n```\n\n\n:::\n:::\n\n\n::: callout-note\n-   p-value = 1.095e-06(\\< 0.05), indicate that the null hypothesis can be rejected.\n\n-   I = 0.3007, indicates **weak** **positive spatial autocorrelation**, meaning that areas with similar values of GDPPC are geographically clustered together.\n:::\n\n## 2.4 Performing Global Moran'I permutation test\n\nIn practice, Monte carlo simulation should be used to perform the statistical test. For sfdep, it is supported by **`global_moran_perm()`**.\n\nTo ensure that the computation is reproducible. Make use of `set.seed()` before perform permutation.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nset.seed(1234)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nglobal_moran_perm(wm_q$GDPPC,\n                       wm_q$nb,\n                       wm_q$wt,\n                  nsim = 99)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n\n\tMonte-Carlo simulation of Moran I\n\ndata:  x \nweights: listw  \nnumber of simulations + 1: 100 \n\nstatistic = 0.30075, observed rank = 100, p-value < 2.2e-16\nalternative hypothesis: two.sided\n```\n\n\n:::\n:::\n\n\n::: callout-note\n-   Notice that the I value is still around 0.3.\n:::\n\n# 3. Computing local Moran'I \n\n\n::: {.cell}\n\n```{.r .cell-code}\nlisa <- wm_q %>%\n  mutate(local_moran = local_moran(\n    GDPPC, nb, wt, nsim = 99),\n    .before = 1) %>%\n  unnest(local_moran) # to expand the local_moran column.\n```\n:::\n\n\n::: callout-note\n-   Notice there are 3 p-value fields(p_ii, p_ii_sim, p_folded_sim) =\\> be consistent , using one of the field to do analysis.\n\n-   There are also 3 clusters field(mean, median, pysal)\n\n    -   median =\\> useful when there is skew (check skewness field, close to 0).\n\n    -   mean =\\> if the data follow standard distribution.\n:::\n\n## 3.1 Visualising local Moran'I\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntmap_mode(\"plot\")\ntm_shape(lisa) +\n  tm_fill(\"ii\") +\n  tm_borders(alpha = 0.5) +\n  tm_view(set.zoom.limits = c(6,8)) +\n  tm_layout(\n    main.title = \"local Moran'I of GDPPC\",\n    main.title.size = 2\n  )\n```\n\n::: {.cell-output-display}\n![](In-class_Ex06_files/figure-html/unnamed-chunk-11-1.png){width=1152}\n:::\n:::\n\n\n## 3.2 Visalising local Moran's I and p-value\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntmap_mode(\"plot\")\nmap1 <- tm_shape(lisa) +\n  tm_fill(\"ii\") +\n  tm_borders(alpha = 0.5) +\n  tm_view(set.zoom.limits = c(6,8)) +\n  tm_layout(\n    main.title = \"local Moran'I of GDPPC\",\n    main.title.size = 1\n  )\n\n\nmap2 <- tm_shape(lisa) + \n  tm_fill(\"p_ii\", breaks = c(0, 0.001, 0.01, 0.05, 1),\n          labels = c(\"0.001\", \"0.01\", \"0.05\", \"Not sig\")) +\n  tm_borders(alpha = 0.5) +\n  tm_layout(\n    main.title = \"p-value of local Moran's I\",\n    main.title.size = 0.8\n  )\n \ntmap_arrange(map1, \n             map2, \n             ncol=2)\n```\n\n::: {.cell-output-display}\n![](In-class_Ex06_files/figure-html/unnamed-chunk-12-1.png){width=1152}\n:::\n:::\n\n\n## 3.3 Visualising LISA map\n\nIn lisa, there are 3 fields contain the LISA categories. They are mean, median and pysal. In general , classification in mean will be used.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlisa_sig <- lisa %>%\n  filter(p_ii < 0.05)\ntmap_mode(\"plot\")\ntm_shape(lisa) +\n  tm_polygons() +\n  tm_borders(alpha = 0.5) +\ntm_shape(lisa_sig) +\n  tm_fill(\"mean\") +\n  tm_borders(alpha = 0.4)\n```\n\n::: {.cell-output-display}\n![](In-class_Ex06_files/figure-html/unnamed-chunk-13-1.png){width=672}\n:::\n:::\n\n\n# 4. Computing local Gi\\* statistics\n\n\n::: {.cell}\n\n```{.r .cell-code}\nwm_idw <- hunan_sf_GDPPC %>%\n  mutate(nb = st_contiguity(geometry),\n         wts = st_inverse_distance(nb, geometry,\n                                   scale = 1,\n                                   alpha = 1),\n         .before = 1)\n```\n:::\n\n\nTo compute local Gi\\*.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nHCSA <- wm_idw %>%\n  mutate(local_Gi = local_gstar_perm(\n    GDPPC, nb, wt, nsim = 99),\n    .before = 1) %>%\n  unnest(local_Gi)\nHCSA\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nSimple feature collection with 88 features and 18 fields\nGeometry type: POLYGON\nDimension:     XY\nBounding box:  xmin: 108.7831 ymin: 24.6342 xmax: 114.2544 ymax: 30.12812\nGeodetic CRS:  WGS 84\n# A tibble: 88 × 19\n   gi_star cluster   e_gi     var_gi std_dev p_value p_sim p_folded_sim skewness\n     <dbl> <fct>    <dbl>      <dbl>   <dbl>   <dbl> <dbl>        <dbl>    <dbl>\n 1  0.0416 Low     0.0114 0.00000641  0.0493 9.61e-1  0.7          0.35    0.875\n 2 -0.333  Low     0.0106 0.00000384 -0.0941 9.25e-1  1            0.5     0.661\n 3  0.281  High    0.0126 0.00000751 -0.151  8.80e-1  0.9          0.45    0.640\n 4  0.411  High    0.0118 0.00000922  0.264  7.92e-1  0.6          0.3     0.853\n 5  0.387  High    0.0115 0.00000956  0.339  7.34e-1  0.62         0.31    1.07 \n 6 -0.368  High    0.0118 0.00000591 -0.583  5.60e-1  0.72         0.36    0.594\n 7  3.56   High    0.0151 0.00000731  2.61   9.01e-3  0.06         0.03    1.09 \n 8  2.52   High    0.0136 0.00000614  1.49   1.35e-1  0.2          0.1     1.12 \n 9  4.56   High    0.0144 0.00000584  3.53   4.17e-4  0.04         0.02    1.23 \n10  1.16   Low     0.0104 0.00000370  1.82   6.86e-2  0.12         0.06    0.416\n# ℹ 78 more rows\n# ℹ 10 more variables: kurtosis <dbl>, nb <nb>, wts <list>, NAME_2 <chr>,\n#   ID_3 <int>, NAME_3 <chr>, ENGTYPE_3 <chr>, County <chr>, GDPPC <dbl>,\n#   geometry <POLYGON [°]>\n```\n\n\n:::\n:::\n\n\n::: callout-note\n-   For HCSA, using the term hot spot and cold spot. Unlike LISA which will using clustering or outliers.\n:::\n\n## 4.1 Visalising local Gi\\* and p-value\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntmap_mode(\"plot\")\nmap1 <- tm_shape(HCSA) +\n  tm_fill(\"gi_star\") + \n  tm_borders(alpha = 0.5) +\n  tm_view(set.zoom.limits = c(6,8)) +\n  tm_layout(main.title = \"Gi* of GDPPC\",\n            main.title.size = 0.8)\n\nmap2 <- tm_shape(HCSA) +\n  tm_fill(\"p_value\",\n          breaks = c(0, 0.001, 0.01, 0.05, 1),\n              labels = c(\"0.001\", \"0.01\", \"0.05\", \"Not sig\")) + \n  tm_borders(alpha = 0.5) +\n  tm_layout(main.title = \"p-value of Gi*\",\n            main.title.size = 0.8)\n\ntmap_arrange(map1, map2, ncol = 2)\n```\n\n::: {.cell-output-display}\n![](In-class_Ex06_files/figure-html/unnamed-chunk-16-1.png){width=1152}\n:::\n:::\n\n\n## 4.1 Visualising hot spot and cold spot area\n\n\n::: {.cell}\n\n```{.r .cell-code}\nHCSA_sig <- HCSA %>%\n  filter(p_sim < 0.05)\ntmap_mode(\"plot\")\ntm_shape(HCSA) +\n  tm_polygons() +\n  tm_borders(alpha = 0.5) +\ntm_shape(HCSA_sig) +\n  tm_fill(\"gi_star\") +\n  tm_borders(alpha = 0.4)\n```\n\n::: {.cell-output-display}\n![](In-class_Ex06_files/figure-html/unnamed-chunk-17-1.png){width=1152}\n:::\n:::\n",
    "supporting": [
      "In-class_Ex06_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}